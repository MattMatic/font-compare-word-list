<html>

<head>
<meta charset="utf-8">
<!--
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gulzar|Noto+Nastaliq+Urdu">
-->
<style>
:root {
  --base-color: #aacccc;
}
  body {
    font-family: "Calibri";
    background-color: var(--base-color);
  }
.test_1 {
  font-family: "Test_Font_1";
  font-kerning: normal;
  font-size: 200%;
  color: #000080;
  text-align: center;
}

.test_2 {
  font-family: "Test_Font_2";
  font-kerning: normal;
  font-size: 200%;
  color: #ee6600;
  text-align: center;
}

.HBC {
  font-family: "Consolas";
  text-align: center;
}

.overlap {
  text-align: center;
  line-height: 0px;
}
.note {
  width: 80%;
}
.info {
  width: 80%;
  font-size: -2;
  background-color: hsl(from var(--base-color) h s calc(l + 5));
  font-family: "Calibri";
}
.HiLite {
  background-color: yellow;
}

input[type="text"] {
  font-size: 100%;
}
.menu-content .searchInput {
  /*font-size:50%;*/
  width: 100%;
}
table, th, td {
  border: 2px solid #448888;
  border-collapse: collapse;
  padding: 8px;
}
td {
  align: 'left';
}
.hbtype table, .hbtype th, .hbtype td {
  border: 0px;
  padding: 4px;
}
.wordlist, input[type="file"] {
  background-color: #8ebf42;
}

.menubtn {
  border-radius: 2px;
  background-color: #eff; /*rgba(96,192,128,0.5);*/
  color: #244;
  padding: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
  font-size: 100%;
  anchor-name: var(--ddmenu);
}
.menu-content {
  position: absolute;
  position-anchor: var(--ddmenu);
  inset: auto;
  top: anchor(bottom);
  left: anchor(left);
  margin-top: 4px;
  background-color: #eff;
  min-width: 200px;
  border-radius: 0px 0px 4px 4px;
  border: 3px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
}
.menu-content a{
  color: black;
  padding: 8px 12px;
  text-decoration: none;
  display: block;  
}
.menu-content a:hover {background-color: #cee;}

.dropbtn {
  border-radius: 4px;
  background-color: rgba(96,192,128,0.5);
  color: black;
  padding: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
  font-size: 100%
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  align: left;
  border-radius: 2px 8px 12px 12px;
  display: none;
  position: absolute;
  background-color: #eff;
  min-width: 200px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}
.dropdown-content a{
  color: black;
  padding: 8px 12px;
  text-decoration: none;
  display: block;
}
th .dropdown-content{
  text-align: left;
  font-weight: bold;
  font-size: 100%;
}
.dropdown-content a:hover {background-color: #cee;}
.dropdown:hover .dropdown-content {
  display: block;
}
.dropdown:hover .dropbtn {
  background-color: #3e8e41;
  color: white;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #ccc;
  color: #006080;
}
.tooltip .tooltiptext {
  visibility: hidden;
  position: absolute;
  width: 340px;
  background-color: #555;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip-bottom {
  top: 135%;
  left: 50%;
  margin-left: -60px;
}
.tooltip-bottom::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  margin-width: 5px;
  border-style: solid;
  border-color: transparent transparent #555 transparent;
}
dialog::backdrop {
  backdrop-filter: blur(1.5px)
  /*background-color: hsl(160, 40%, 50%, 0.2);*/
}
dialog {
  background-color: #e8ece8;
}
[aria-label="close"] {
  appearance: none;
  background-color: #fcc;
  float: right;
  border: 1px solid;
  border-radius: 50%;
}
.prContainter {
  /*
  white-space: nowrap;
  width:600px;
  height:400px;
  */
  overflow-x: scroll;
  overflow-y: auto;
}
.prContent {
  width:800px;
  height:600px;
  display: block;
  white-space: nowrap;
  overflow-y: scroll;
  overflow-x: scroll;
  font-family: monospace;
}
</style>

<script type="text/javascript" src="./js/hbjs-11.0.1/hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="./js/hbjs.js"></script> <!-- Wrapper, can be used without -->
<script type="text/javascript" src="./js/fontname.min.js"></script>
<script type="text/javascript" src="./js/flatbezier.js"></script>
<script type="text/javascript" src="./js/otinfo.min.js"></script>
<script type='module' src="./js/glyphcompare.mjs" async></script>
<script type='module' defer>
import {CPaths64, GlyphCompareClass} from './js/glyphcompare.mjs';

import * as opentype from './js/opentype.min.mjs';
import Layout from './js/opentype.layout.gdef.mjs';
window.opentype = opentype;
window.Layout = Layout;

window.CPaths64 = CPaths64;
window.GlyphCompareClass = GlyphCompareClass;
function onResourcesLoaded() {
  window.loadFromLocalStorage();
  if ((window.opener !== null) && (window.opener.openFontCompareWordListTool)) {
    window.acquireFontAndLists(window.opener);
  }
  window.toggleHBIcons();
  /*
  import('./js/glyphcompare.mjs').then((module) => {
    GlyphCompare = module;
  });
  */
}

createHarfBuzz().then(hbmodule=>{
  const hb = loadedHarfBuzzModule(hbmodule);
  setHarfBuzzFontObjects(hb, hb);
  onResourcesLoaded();
});
</script>

<script>
"use strict";

var text_align = 'center';    // Used for SVG and HTML align
var svgScale = 100;
var doShowFontTwo = false;
var svgFont1 = true;
var svgFont2 = true;

let hbVersions = [];

async function loadHarfBuzzVersion(hbf, version) {
  if (hbVersions[version]) {
    hbf.setHarfBuzz(hbVersions[version]);
    updateListByField();
  }
  const scriptSource = `./js/hbjs-${version}/hb.js`;
  const newScriptElement = document.createElement('script');
  newScriptElement.onload = function() {
    createHarfBuzz().then(hbmodule=>{
      loadedHarfBuzzModule(hbmodule);
      hbf.setHarfBuzz(hbVersions[version]);
      if (hbf === hbf1) {
        hbf2.setHarfBuzz(hbVersions[version]);
        hbVersion2.value = version;
      }
      updateListByField();
    });
  }
  newScriptElement.onerror = function() {
    window.alert(`Could not load HarfBuzz ${version}`);
  }
  newScriptElement.src = scriptSource;
  document.head.appendChild(newScriptElement);
}

function loadedHarfBuzzModule(module) {
  const hb = hbjs(module);
  window.harfBuzz = {
    module: module,
    hb: hb,
  };
  const version = hb.version_string();
  hbVersions[version] = hb;
  return hb;
}

//------------------------------
// Drag and drop utilities
//------------------------------

function chooseFile(func) {
  var filein = document.createElement('input');
  filein.type = 'file';
  filein.onchange = e => {
    var file = e.target.files[0];
    func(file, e);
  }
  filein.click();
  try {
    document.body.removeChild(filein);
  } catch (e) {
    // ignore
  }
}

function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
  ele.addEventListener('mousedown', function(e) {
    if (e.button === 2) {
      chooseFile(foo);
    }
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);
window.addEventListener('beforeunload', function(e) {
  if (!checkListChanged) return undefined;
  var confirmMessage = 'CheckList is not yet saved. If you leave before saving, changes will be lost!';
  (e || window.event).returnValue = confirmMessage;
  return confirmMessage;
});


function elementHidePopover(e) {
  if (e && e.parentElement && e.parentElement.hidePopover) {
    e.parentElement.hidePopover();
  }
}

//------------------------------
// Document/CSS Font Utilities
//------------------------------
function changeFontAscentDescent(name, asc, desc) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        v.ascentOverride  = asc;
        v.descentOverride = desc;
      }
    }
  );
}

function deleteFontByName(name) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        document.fonts.delete(v);
      }
    }
  );
}

//------------------------------
// Build table
//------------------------------
var start_index = 1
var per_block = 5; //100
var line = 1

var update_interval = 131;
var checkListChanged = false;
var wordlist_filename = '';

function disableSaveButton() {
  saveButton.disabled = true;
  saveButton.style = '';
}

function enableSaveButton() {
  saveButton.disabled = false;
  saveButton.style = 'background-color:#f44336; color:white';
}

function checkListHasChanged() {
  checkListChanged = true;
  enableSaveButton();
}

function resetCheckListChanged() {
  checkListChanged = false;
  disableSaveButton();
}

function wordHTML(txt,fnt) {
  //return '<div class="'+fnt+'" align="center"><p>'+txt+'</p></div>'
  return '<div class="'+fnt+'"><p>'+txt+'</p></div>'
}

function MarkUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setChecked(e.checked);
  updateCheckListCount();
  checkListHasChanged();
}

function BuildMarkHtml(n) {
  var txt = '<input type="checkbox" onclick="MarkUpdate(this);" name="mark'+(n+1)+'"';
  if (wordList[n].getChecked()) txt = txt + ' checked';
  txt = txt + '>';
  return txt;
}

function NoteUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setNote(e.value);
  checkListHasChanged();
}

function InfoUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setInfo(e.value);
  checkListHasChanged();
}

function escapeQuotes(txt, quote) {
  const qs = quote || '\'';
  return txt.replace(quote, '"');
}

function BuildNoteHtml(n) {
  var txt = '';
  txt += `<input type="text" class="note" onchange="NoteUpdate(this);" onkeyup="NoteUpdate(this); name="note${n+1}" value="${wordList[n].getNote()}">`;
//  txt += `<br/><font size=-1>info:<input type="text" class="info" onchange="InfoUpdate(this);" onkeyup="InfoUpdate(this); name="info${n+1}" value='${escapeQuotes(wordList[n].getInfo())}''></font>`;
  txt += `<br><font size=-1>Info:<textarea class='info' onchange='InfoUpdate(this);' onkeyup='InfoUpdate(this);' rows=3 name='info${n+1}'>${wordList[n].getInfo()}</textarea>`;
  return txt;
}

function BuildDifference(n, phrase) {
  if (!HBCGlive.checked) return '';
  const we = wordList[n];
  let da = we.getDifferenceArea();
  if (typeof da === 'undefined') da = we.calcDifferenceArea(hbf1, hbf2);
  if (da === 0) return '';
  //let txt = `Diff:${da}</br><font size=-1>Adv:${we?.totalAdv[1]-we?.totalAdv[2]}=${Math.round(we?.totalAdv[0]*1000)/10}%</font>`;
  let txt = `Diff:${da}</br><font size=-1>Adv:${we?.totalAdv[1]-we?.totalAdv[2]}=${Math.round(differenceRatio(we?.totalAdv[1], we?.totalAdv[2])*1000)/10}%</font>`;
  return txt;
}

const hb_icons = {
  identical: ['&#x2705;' , '‚úÖ',  64],     // Green tick
  count    : ['&#x1F7E5;', 'üü•', 128],     // Red
  total    : ['&#x1F7E0;', 'üü†',  32],     // Orange circle
  cluster  : ['&#x1F7E8;', 'üü®',   2],     // Yellow
  advance  : ['&#x1F7E6;', 'üü¶',   8],     // Blue
  offset   : ['&#x1F7EA;', 'üü™',   4],     // Purple
  gid      : ['&#x2b1c;' , '‚¨ú',   1],     // White
  reg_exp  : new RegExp('[‚úÖüü•üü†üü®üü¶üü™‚¨ú]', 'gu')
};

function diffFieldToText(diff) {
  var res = '';
  if (diff < 0) return '';
  if ((diff == 0) || (diff === 64)) return hb_icons.identical[0];
  const sep = "";//</br>";
  if (0 != (diff & hb_icons.count[2]))    res = res + hb_icons.count[0]   + sep;
  if (0 != (diff & hb_icons.cluster[2]))  res = res + hb_icons.cluster[0] + sep;
  if (0 != (diff & hb_icons.advance[2]))  res = res + hb_icons.advance[0] + sep;
  if (0 != (diff & hb_icons.offset[2]))   res = res + hb_icons.offset[0]  + sep;
  if (0 != (diff & hb_icons.total[2]))    res = res + hb_icons.total[0] + sep;
  //if (0 != (diff & hb_icons.gid[2]))   res = res + hb_icons.gid[0]     ;//+ "</br>";
  return res;
}

function diffValueToUnicode(diff) {
  var res = '';
  if (diff < 0) return res;
  if ((diff == 0) || (diff === 64)) return hb_icons.identical[1];
  if (0 != (diff & hb_icons.count[2])) res = res + hb_icons.count[1];
  if (0 != (diff & hb_icons.cluster[2]))   res = res + hb_icons.cluster[1];
  if (0 != (diff & hb_icons.advance[2]))   res = res + hb_icons.advance[1];
  if (0 != (diff & hb_icons.offset[2]))   res = res + hb_icons.offset[1];
  if (0 != (diff & hb_icons.total[2]))    res = res + hb_icons.total[1];
  //if (0 != (diff & hb_icons.gid[2]))   res = res + hb_icons.gid[1];
  return res;
}

function diffValueToNote(existingNote, diff) {
  var res = existingNote;
  res = res.replace(hb_icons.reg_exp, '');
  return res + diffValueToUnicode(diff);
}

var tolCompare;

function differenceRatio(a, b) {
  return (a-b) / ((a+b)/2);
}

function generateToleranceCompareFunction(tolerance) {
  var fn;
  if (tolerance && (tolerance !== '')) {
    let gt = true;
    if (tolerance.startsWith('<')) {
      // Looking for less than
      gt = false;
      tolerance = tolerance.substr(1);
    }
    if (tolerance.includes('%')) {
      const tol = parseFloat(tolerance) / 100;

      fn = function(a, b) {
        if (Math.abs(differenceRatio(a, b)) > tol) {
          return gt;
        }
        return !gt;
      }
    } else {
      const diff = parseFloat(tolerance);
      fn = function(a,b) {
        if (Math.abs(a-b) > diff) return gt;
        return !gt;
      }
    }
  } else {
    fn = function(a,b) {
      if (a !== b)
        return true;
      else
        return false;
    }
  }
  return fn;
}

tolCompare = generateToleranceCompareFunction(null);

function updateTolerance() {
  var tolerance = HBCC_tolerance.value;
  tolCompare = generateToleranceCompareFunction(tolerance);
  updateListByField();
}

function addEntry(table, lineNo, theWordEntry) {
  //if (txt == '') return;
  var row = table.insertRow();
  var idx=1;

  var phrase = theWordEntry.getWord();
  hbf1.shape(phrase);
  theWordEntry.updateGids(hbf1);  
  hbf2.shape(phrase);
  var diff = hbf1.compare(hbf2, tolCompare);
  theWordEntry.setDiff(diff);

  row.insertCell(0).innerHTML = '<div align="center">'+(lineNo+1)
      +BuildMarkHtml(lineNo)
      +' '+BuildNoteHtml(lineNo)
      +'</div>';
  row.insertCell(idx++).innerHTML = '<div class="HBC">'
      //diffFieldToText(diff)+
      +theWordEntry.getDiff()
      +'</br>'+BuildDifference(lineNo, phrase)
      +'</div>';
  row.insertCell(idx++).innerHTML = wordHTML(phrase, "test_1");
  var cell = row.insertCell(idx++);
  if (hbf2.font && doShowFontTwo) {
    cell.innerHTML = wordHTML(phrase, "test_2");
  }
  cell = row.insertCell(idx++);

  let html = `<p class="overlap" id="overlap${lineNo}">`;

  //~~//html += `<span class="test_2" style="color: #ff6600;">${phrase}</span><br><span class="test_1">${phrase}</span>`;
  html += hbf1.genSVGcombined(phrase, hbf2, true,
    {
      width:200, 
      height:100, 
      scale:svgScale,
      font1:svgFont1,
      font2:svgFont2,
    });
  html += '</p>';
  cell.innerHTML = html;
}

function UpdateListener(id, event, foo) {
  const e = document.getElementById(id);
  if (e)  {
    e.addEventListener(event, function(e) {
      foo(e);
    });
  }
}

async function hbVersionChange(event) {
  const hbVersion1 = document.getElementById('hbVersion1');
  const hbVersion2 = document.getElementById('hbVersion2');
  if (event.srcElement == hbVersion1) {
    await loadHarfBuzzVersion(hbf1, hbVersion1.value);
    //hbVersion2.value = hbVersion1.value; // done in the async
  } else {
    await loadHarfBuzzVersion(hbf2, hbVersion2.value);
  }
  //updateListByField();
}

function createHarfBuzzChoice(id, name, value) {
  const hbVersionsAvailable = [
    '12.3.0',
    '12.2.0',
    '12.0.0',
    '11.5.0',
    '11.4.5',
    '11.3.3',
    '11.0.1',
  ];
  let html = `<select name="${name}" id="${id}">\r\n`;
  hbVersionsAvailable.forEach(v=>{
    html += `<option value="${v}"${value===v?" selected":""}>${v}</option>\r\n`;
  });
  html += '</select>';
  return html;
}

function addWordListFooter(table) {
  const row = table.insertRow();
  let cell = row.insertCell(0);
    cell.innerHTML = 'Force Field Glyph Info: üü•GG üüßcb üü™cx üü¶cm üü¢glue üü°gap';
    cell.align = 'center';
  row.insertCell(1);
  cell = row.insertCell(2);
    cell.innerHTML = createHarfBuzzChoice('hbVersion1', 'hbVersion1', hbf1.hbVersion);
    cell.align = 'center';
  cell = row.insertCell(3);
    cell.innerHTML = createHarfBuzzChoice('hbVersion2', 'hbVersion1', hbf2.hbVersion);
    cell.align = 'center';
  row.insertCell(4).innerHTML = 'HarfBuzz version <button onclick="checkWhetherClearCache();">Clear cache</button>';
  UpdateListener('hbVersion1', 'change', hbVersionChange);
  UpdateListener('hbVersion2', 'change', hbVersionChange);
}

function updateListByIndex(idx) {
  updateHarfBuzzScriptLanguage();

  const table = document.getElementById('word_list')
  var s = table.rows.length;
  while (s > 1) {
    s--;
    table.deleteRow(s);
  }
  var n =  per_block;
  for (var i=(idx-1); i < (idx-1+n); i++) {
    if (wordList[i] === undefined) break;
    addEntry(table, i, wordList[i]);
  }
  addWordListFooter(table);
  const e = document.getElementById('start');
  e.value = String(idx);
}

function getStart() {
  var txt = document.getElementById('start').value;
  if (isNaN(txt)) return start_index;
  var i = Number(txt);
  if (i < 1) {
    i = 1;
  }
  if (i > wordList.length) {
    i = wordList.length-1;
  }
  return i;
}

function setStart(idx) {
  document.getElementById('start').value = String(idx);
}

function gotoOrFind() {
  var txt = document.getElementById('start').value;
  if (isNaN(txt)) {
    // Let's try and locate...
    var search_index = start_index;
    const list_length = wordList.length;
    while (search_index < list_length) {
      if (wordList[search_index].getWord().search(txt) >= 0) {
        start_index = search_index + 1;
        setStart(start_index);
        updateListByIndex(start_index);
        document.getElementById('start').value = txt; // Keep text in the search
        break;
      }
      search_index++;
    }
    // Not found!
    //document.getElementById('start').value = start_index;
  } else {
    // This is a number... let's jump to the location
    updateListByField();
  }
}

function updateListByField() {
  start_index = getStart();
  if (start_index <= 1) start_index = 1;
  setStart(start_index);
  updateListByIndex(start_index);
}

function updateListNext() {
  start_index = getStart() + per_block;
  if (start_index > wordList.length) start_index = wordList.length - 2;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}

function updateListPrev() {
  start_index = getStart() - per_block;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}

function updateListFirst() {
  start_index = 1;
  updateListByIndex(start_index);
}

function updateListLast() {
  start_index = wordList.length - per_block + 1;
  updateListByIndex(start_index);
}

function updateCssStyle(name, styleid, value) {
  const rules = document.styleSheets[0].cssRules;
  for (var i=0, rl=rules.length; i<rl; i++) {
    if (rules[i].selectorText == name) {
      rules[i].style[styleid] = value;
      break;
    }
  }
}

function updateAlign() {
  const alignRadios = document.getElementsByName('alignment');
  for (var i=0, rl=alignRadios.length; i<rl; i++) {
    if (alignRadios[i].checked) {
      text_align = alignRadios[i].value;
      break;
    }
  }
  updateCssStyle('.test_1', 'text-align', text_align);
  updateCssStyle('.test_2', 'text-align', text_align);
  updateCssStyle('.overlap', 'text-align', text_align);
  updateListByField();
}

function updatePerPage(v) {
  per_block = v;
  updateListByField();
}

function updateHbShow(f1, f2) {
  svgFont1 = f1;
  svgFont2 = f2;
  updateListByField();
}

function cssRulesIterate(func) {
  const ruleList = document.styleSheets[0].cssRules;
  for (const rule of ruleList) {
    func(rule);
  }
}

function setFontSize(size) {
  cssRulesIterate(rule => {
    if (rule.selectorText.startsWith('.test_')) {
      rule.style.fontSize = size;
    }
  });
  svgScale = parseInt(size, 10) / 2;
  updateListByField();
}

</script>
</head>

<body>

<h1>
  Font Compare Word List Tool
</h1>

<table width="100%" border=1>
  <tr>
    <td width="22%">
      Actions
    </td>
    <td>
      <button id='saveButton' onclick='saveToLocalStorage();' disabled=true title='Save state in localStorage'>Save</button>
      &bull;
      <button onclick='clearLocalStorage();' title='Reset and Clear'>Reset</button>

      <div class='dropdown'>
        <!--<button class='dropbtn'></button>-->
        <div class='dropdown-content' id='ddProgress'>
          <table border=0 width='100%'><tr><th>Progress:</th><td><div id='statusUpdate'>-</div> <button onclick='doAbortLongRunning();' id='AbortButton' hidden>Abort!</button></td></tr></table>
        </div>
      </div>
    </td>
  </tr>
</table>

<table border=1 cellspacing="8px" width="100%">
  <tr>
    <td width='22%'>
      <label for='start'>Start:</label><input type='text' id='start' placeholder='Start' value='1' width='8'/>
      <button onclick='gotoOrFind();' title='Jump to "Start" as a line number, or &#13;&#10; search for the text in "Start"'>Go</button><br/>
      Page:<input type='radio' name='perPage' value=5 onclick='updatePerPage(5);' checked><label>5</label>
      <input type='radio' name='perPage' value=10 onclick='updatePerPage(10);'><label>10</label>
      <input type='radio' name='perPage' value=25 onclick='updatePerPage(25);'><label>25</label>
    </td>
    <td width='26%' align='center'>
      <button onclick='updateListFirst();' accesskey='1'>First (Alt-1)</button>
      <button onclick='updateListPrev();' accesskey='2'>Prev (Alt-2)</button>
      <button onclick='updateListNext();' accesskey='3'>Next (Alt-3)</button>
      <button onclick='updateListLast();' accesskey='4'>Last (Alt-4)</button>
    </td>
    <td width="26%" id='WordsDragDrop' align='center'>
      <span id='wordcount'><b><span style='background-color:cyan;'>Drag-and-drop Word List (.txt) file here</b></span></span>
    </td>
    <td align='center'>
      <span>
        <input type='radio' name='alignment' value='left' onclick="updateAlign();">
          <label for='left'>Left</label>
        <input type='radio' name='alignment' value='center' onclick="updateAlign();" checked>
          <label for='center'>Center</label>
        <input type='radio' name='alignment' value='right' onclick="updateAlign();">
          <label for='right'>Right</label>
      </span>
    </td>
  </tr>
</table>
</br>

<!-- Menus Start -->
  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddWordList'>üî§Word List</button>
    <div class='menu-content' id='ddWordList' popover>
    <a href='#' onclick='DownloadCheckList(this);' title='Save check list to file'>‚è¨Download</a></br>
    <!--<a href='#' onclick='pasteUniqueWords();' title='Paste Unique words - new words are checked'>‚≠êPaste Unique</a></br>-->
    </div>
  </div>
  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddSortList'>üìäSort</button>
    <div class='menu-content' id='ddSortList' popover>
    <p><input type='checkbox' id='cbCheckedFirst' checked><label for='cbCheckedFirst'>Checked + ‚Ä¶</label></input></p>
    <a href='#' onclick='SortWordList(this, false);' title='Sort by Word'>üî§Word</a></br>
    <!--<a href='#' onclick='SortWordList(this, false, true);'  title='Sort by Check then Word'>‚úÖCheck + Word</a></br>-->
    <a href='#' onclick='SortWordList(this, true);'  title='Sort by Note then Word'>üììNote + Word</a></br>
    <a href='#' onclick='SortWordListByInfo(this);'  title='Sort by FFFT Info'>üü•Force Field Glyph Info + Word</a></br>
    <a href='#' onclick='SortWordListArea(this);'  title='Sort by Difference Area'>üìêArea + Word</a></br>
    </div>
  </div>
  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddCheckList'>‚úÖCheck List</button>
    <div class='menu-content' id='ddCheckList' popover>
    <a href='#' onclick='ClearCheckListUser(this);' title='Remove check from all words'>‚¨úClear All</a></br>
    <a href='#' onclick='CheckAllList(this);' title='Check all words'>‚úÖSet All</a></br>
    <a href='#' onclick='InvertCheckList(this);' title='Toggle check for all words'>üîµInvert</a></br>
    <a href='#' onclick='CheckNotes(this);' title='Check all words that have some text in the note field'>üììCheck Notes</a></br>

    <a href='#' onclick='openFontCompareTool(this);' title='Send checked words to HarfBuzz Font Compare Tool'>‚ûú Font Compare</a></br>
    <a href='#' onclick='openFontForceFieldTool(this);' title='Send checked words to Font Force Field Tool'>‚ûú Force Field</a></br>

    <span id='gidGposAnalytics' hidden><a href='#' onclick='processChecklistGpos(this);' title='Process GPOS/GID data'>üìà Glyph/GPOS analytics</a></span></br>
    </div>
  </div>

  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddSearch'>üîçSearch</button>
    <div class='menu-content' id='ddSearch' popover>
      <table border=0>
        <tr><th>Notes:</th><td><input class='searchInput' type='text' name='regExpNotes' id='regExpNotes'/></td></tr>
        <tr><th>Info:</th><td><input class='searchInput' type='text' name='regExpInfo' id='regExpInfo'/>
          <input type='checkbox' id='cbInfoNoIcons'>Ignore Glyph Icons</input>
          <input hidden type='text' id='txtNoIcons' value='(üü•|üüß|üü™|üü¶|üü¢|üü°|‚Ü≥)'></input>
        </td></tr>
        <tr><th>Word:</th><td><input class='searchInput' type='text' name='regExpWord' id='regExpWord'/></td></tr>
        <tr><th>Glyph(s):</th><td><input class='searchInput' type='text' name='regExpGlyph' id='regExpGlyph' title='Integer or string. Separate gids or expressions with a comma.&#13;&#10;To search for sequences of glyph-sets separate each set with ||' disabled/>
        </td></tr>
        <tr><th>GPOS:</th><td><input class='searchInput' type='text' name='regExpGpos' id='regExpGpos' title='Integer or string. Separate multiple with comma' disabled/>
        </td></tr>
        <tr><th></th><td>Regular Expression Hint: ^=start, $=end, \=escape</td>
        <tr><th>Check:</th><td>
          <input type='radio' name='regExpOp' value='check' checked><label for='check'>Check</label></br>
          <input type='radio' name='regExpOp' value='uncheck'><label for='uncheck'>Uncheck</label></br>
          <input type='radio' name='regExpOp' value='invert'><label for='invert'>Invert</label>          
        </td></tr>
        <tr><th></th><td>
          <button onclick='ddSearch.hidePopover(); CheckmarkRegExp();' title='Run regular expression and adjust check'>Search</button>
        </td></tr>
      </table>
    </div>
  </div>

  <div class='dropdown'>
    <button class='menubtn' onclick='dlgPatternSearch.showModal();' id='btnPatternSearch'>üé∂Patterns</button>
  </div>

  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddHarfBuzz'>&#x1F30D;HarfBuzz</button>
    <div class='menu-content' id='ddHarfBuzz' popover>
      <table border=0>
        <tr><th width='20%'>HTML Lang:</th><td><input type='text' id='HTMLLang' oninput='updateLanguage();' title='Web page language ID'/></td></tr>
        <tr><th>Script:</th><td>
          <span class='tooltip'>
            <input type='text' id='inputScript' oninput='updateLanguage();'/>
            <span class='tooltiptext tooltip-bottom' id='inputScriptList'>-</span>
          </span>
        </td></tr>
        <tr><th>Language:</th><td>
          <span class='tooltip'>
            <input type='text' id='inputLanguage' oninput='updateLanguage();'/>
            <span class='tooltiptext tooltip-bottom' id='inputLanguageList'>-</span>
          </span>
          </td></tr>
        <tr><th>Fix:</th><td>
          <input type='checkbox' id='cbHarfBuzzFix' title='Uncheck=browser style rendering; Checked=trace-fix (e.g. Noto Bengali)' onchange='cbHarfBuzzFixChange();'>Trace-Fix for shaping</input>
        </td></tr>
        <tr>
          <th><button onclick='CheckSimilar();' title='Check all words where HarfBuzz output is the same (Compare GIDs is considered)'>Compare and Check</button></th>
          <td>
            <table class='hbtype'>
              <tr>
                <td><input type='checkbox' id='HBCC_count'>üü•Different Glyph Count</input></td>
                <td align='right'><span id='HBCC_count_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_clusters'>üü®Different Clusters</input></td>
                <td align='right'><span id='HBCC_clusters_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_advance'>üü¶Different Advance *</input></td>
                <td align='right'><span id='HBCC_advance_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_total'>üü†Total Advance *</input></td>
                <td align='right'><span id='HBCC_total_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_offset'>üü™Different Offset *</input></td>
                <td align='right'><span id='HBCC_offset_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_gid' checked>‚¨úDifferent GIDs</input></td>
                <td align='right'><span id='HBCC_gid_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_identical' checked>‚úÖExact</input></td>
                <td align='right'><span id='HBCC_identical_no'></span></td>
              </tr>
              <tr>
                <td><label for='HBCC_tolerance'>Tolerance:(*)</label><input type='text' id='HBCC_tolerance' oninput='updateTolerance();' title='Tolerance for Offset & Advance&#13;&#10; - either a value in designUnits (e.g. 10), or a percentage (e.g. 10%)&#13;&#10;Prefix with `<` for less than.' value='5%'></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <th><button onclick='ddHarfBuzz.hidePopover(); UpdateDifferences();' title='Regression test:&#13;&#10;For each word where HarfBuzz differs between Font#1 and Font#2 -> toggle the check.&#13;&#10;&#13;&#10;Words left checked will be:&#13;&#10;‚Ä¢ requested changes that did not occur&#13;&#10;‚Ä¢ unexpected changes'>Update Differences</button></th>
          <td><input type='checkbox' id='HBGIDs' oninput='updateLanguage();' title='Unchecked = ignore glyph ID when comparing; Checked = compare glyph ID in HarfBuzz output'>Compare GIDs</input></td>
        </tr>
        <tr>
          <th><button onclick='ddHarfBuzz.hidePopover(); CheckDifferentGlyphs();' title='Render the outlines and check any that have large difference area'>Compare Outlines</button></th>
          <td>
            <font color='red'>EXPERIMENTAL</font></br>
            <input type='text' id='HBCGtolerance' title='1000s designUnits^2 area tolerance' value='20'></input></br>
          </td>
        </tr>
        <tr>
        <th></th>  
          <td>
            <input type='checkbox' id='HBCGlive' onchange='updateHBCGlive();'>Show data in table</input>
          </td>
        </tr>
      </table>
    </div>
  </div>      

  <div class='dropdown'>
    <button class='menubtn' popovertarget='ddDelete'>‚ùåDelete</button>
    <div class='menu-content' id='ddDelete' popover>
    <a href='#' onclick='DeleteDuplicates(this);' title='Remove all duplicate words'>üìöDelete Duplicates</a></br>
    <a href='#' onclick='RemoveUnchecked(this);' title='Remove all words that are NOT checked (cannot be undone!)'>‚ùåDelete Unchecked</a></br>
    <a href='#' onclick='DeleteAll(this);' title='Remove all words (cannot be undone!)'>‚õîDelete All</a></br>
    </div>
  </div>
<!-- Menus End -->

<table border=2 cellspacing="8px" width='100%' id='word_list'>
  <tr>
    <th width='16%' id='checkListHeading'>
      # / Note</br><span style='font-size:75%' id='CheckListCount'></span>      
    </th>
    <th width='6%'>
      <!--<a href='javascript:void(0)' onclick='toggleHBIcons();'>Diff</a>-->
      Diff
      <div class='dropdown'>
        <button class='dropbtn'>&nbsp;?&nbsp;</button>
        <div class='dropdown-content'>
        <div id='HBIcons' hidden>
        </div>
      </div></div>
    </th>
    <th width='26%' id='fontOneInfoCell'>
      <span id='fontOneInfo'>Drag-and-Drop Font 1</span>
      <div class='dropdown'>
        <button class='dropbtn'>‚Ä¶</button>
        <div class='dropdown-content'>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("100%");'>100%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("200%");'>200%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("300%");'>300%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("400%");'>400%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("500%");'>500%</button></br>
        </div>
      </div>
    </th>
    <th width='26%' id='fontTwoInfoCell'>
      <span id='fontTwoInfo'>Drag-and-Drop Font 2</span>
      <div class='dropdown'>
        <button class='dropbtn'>‚Ä¶</button>
        <div class='dropdown-content'>
          <button class='dropbtn' style='width:50%' onclick='showFontTwo(false);'>Hide</button></br>
          <button class='dropbtn' style='width:50%' onclick='showFontTwo(true);'>Show</button>
        </div>
      </div>
    </th>
    <th width='26%' id='fontOverlap'>
      HarfBuzz Render<br/>
      <input type='radio' name='hbShow' value='one' onclick='updateHbShow(true, false);'>Font 1</input>
      <input type='radio' name='hbShow' value='two' onclick='updateHbShow(false, true);'>Font 2</input>
      <input type='radio' name='hbShow' value='overlap' onclick='updateHbShow(true, true);' checked>Overlap</input>
    </th>
  </tr>
</table>

<dialog id='dlgPatternSearch'>
  <button type='submit' aria-label='close' onclick='dlgPatternSearch.close();'>X</button>
  <h2>Pattern Search</h2>
  <table border=0>
    <tr><td>Info Search:</td><td><input style='width:100%;' class='searchInput' type='text' name='txtPatternMatchText' id='txtPatternMatchText'/></td></tr>
    <tr><td>Parameters:</td>
      <td>
        Min Count: <input style='width:10%;' type='text' id='txtMinMatch' value='2'></input> &nbsp;
        Max Gap: <input style='width:10%;' type='text' id='txtMaxGap' value='1'></input> &nbsp;
        <input type='checkbox' id='cbPatternSortLength'><label for='cbPatternSortLength'>Length Sort</label></input>
      </td>
    </tr>
    <!--
    <br/>Dist 1<input type='text' id='txtDist1' value='1'></input>
    <br/>Dist 2<input type='text' id='txtDist2' value='2'></input>
    -->
    <tr><td> </td><td>
      <button onclick='patternMatchFind();' id='btnPatternMatch'>Find Matches</button> 
      <button onclick='copyPatternResultsToClipboard();' id='btnPatternMatchCopy'>Copy to Clipboard</button>
      <button onclick='patternResultsCheckmark();' id='btnPatternResultsCheck'>Checkmark Words</button>
      </td>
    </tr>
    <tr><td>Output:</td><td>
      <div id='divPatternResults'> &nbsp; </div>
      <div class='prContainer'>
        <div class='prContent' id='divPatternOutput'> </div>
        <!--<textarea rows=20 cols=60 id='taPatternOutput' wrap='off' style='font-family:monospace;' spellcheck='false'></textarea>-->
      </div>
      </td>
    </tr>
  </table>
</dialog>

</p>

<p>
<button onclick='updateListByField(); window && window.scroll(0,0)'>TOP</button>
<button onclick='updateListNext(); window && window.scroll(0,0)'>Next</button>
</p>
<table width="100%" border=1>
  <tr>
    <td width='22%' id='CheckDragDrop' align='left'>
        <b><span style='background-color:cyan;'>Drag-and-drop CheckList .txt here</span></b>
    </td>
    <td>
    </td>
  </tr>
</table>
</p>

<script>

function isExists(v) {
  if ((typeof(v) === 'object') && (v === null)) return false;
  return typeof(v) !== 'undefined';
}

function isAssigned(obj) {
  if (typeof obj === 'undefined') return false;
  if (obj === null) return false;
  return true;
}

function updateSvg(dive, html) {
  var oldScale = 1;
  var oldTranslate = {x:0, y:0};

  var svge = dive.children[0];
  if (typeof svge !== 'undefined') {
    oldScale = svge.currentScale;
    oldTranslate = svge.currentTranslate;
  }
  dive.innerHTML = html;
  svge = dive.children[0];
  svge.currentScale = oldScale;
  svge.currentTranslate.x = oldTranslate.x;
  svge.currentTranslate.y = oldTranslate.y;
}

function fillOtInfoTables(fontInfo) {
  fontInfo.scripts = new Set();
  fontInfo.languages = new Set();
  fontInfo.features = new Set();

  let doGtable = function(t) {
    if (!t) return;
    if (t.scriptTable) {
      for (const key in t.scriptTable) {
        fontInfo.scripts.add(key);
        for (const val of t.scriptTable[key]) {
          fontInfo.languages.add(val);
        }
      }
    }
    if (t.featureListTable) {
      for (const val of t.featureListTable) {
        fontInfo.features.add(val);
      }
    }
  }
  doGtable(fontInfo.GSUB);
  doGtable(fontInfo.GPOS);
}

class hbFont {
  constructor(hb) {
    this.script = 'latn';
    this.lang   = '';
    this.features = '';
    this.results = {};
    this.results.json = null;
    this.hbFix = false;
    //this.setHarfBuzzModule(hbModule, hb);
    this.hb = hb;
  }
  setHarfBuzz(hb) {
    const fbOld = this.fontBlob;
    this.freeFont();
    this.hb = hb;
    if (hb) {
      this.hbVersion = hb.version_string();
    }
    this.setFontBlob(fbOld);
  }
  destroy() {
    this.freeFontBlob();    
  }
  freeFontBlob() {
    this.freeFont();
    this.fileDescription = null;
    delete(this.fontBlob);
  }
  freeFont() {
    this.results = {};
    if (this.font) { this.font.destroy(); delete(this.font); }
    if (this.face) { this.face.destroy(); delete(this.face); }
    if (this.blob) { this.blob.destroy(); delete(this.blob); }
    delete(this.otLayout);
    delete(this.otFont);
    if (this.gc) this.gc.destroy();
    delete this.gc;
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    if (fb) {
      const fontName = FontName.parse(fb)[0];
      //console.log(fontName);
      this.fileDescription = fontName.fullName + '</br>' + fontName.version;
    } else {
      this.fileDescription = '';
    }
    if (!fb) return;
    const otInfo = OTInfo.parse(fb);
    this.fontInfo = otInfo[0];
    fillOtInfoTables(this.fontInfo);
    this.blob = this.hb.createBlob(this.fontBlob);
    this.face = this.hb.createFace(this.blob, 0);
    this.font = this.hb.createFont(this.face);
    const debgTable = this.face.reference_table("Debg");
    if (debgTable) {
      this.debugInfo = JSON.parse(new TextDecoder("utf8").decode(debgTable));
      this.debugInfo = this.debugInfo["com.github.fonttools.feaLib"];
    } else {
      this.debugInfo = null;
    }
    this.otFont = opentype.parse(this.fontBlob);
    this.otLayout = new Layout(this.otFont, 'GPOS');

    // Let's cache the glyph names and the mark class gids
    this.glyphNameToGid = new Map();
    this.setGidIsMark = new Set();
    const max = this.otFont?.glyphs?.length;
    for (let gid=0;gid<max;gid++) {
      const gn = this.getGlyphName(gid);
      this.glyphNameToGid.set(gn?gn:gid, gid);
      if (this.getGlyphClass(gid) === 3) this.setGidIsMark.add(gid);
    }

    this.gc = new GlyphCompareClass(this.hb);
    this.gc.setFontBlob(this.fontBlob);
    this.gc.setScriptLanguage(this.script, this.lang);
  }
  setScriptLang(script, lang) {
    this.script = script;
    this.lang = lang;

    if (this.gc)
      this.gc.setScriptLanguage(this.script, this.lang);
  }
  shape(txt) {
    if (!this.fontBlob) return;
    var buffer = this.hb.createBuffer();
    buffer.addText(txt);
    buffer.guessSegmentProperties();
    if ((typeof this.script === 'string') && (this.script.length > 0))
      buffer.setScript(this.script || 'latn');
    if ((typeof this.lang === 'string') && (this.lang.length > 0))
      buffer.setLanguage(this.lang);
    if (!this.hbFix) {
      this.hb.shape(this.font, buffer, this.features);
    } else {
      const exports = this.hb.hooks.exports;
      const addFunction = this.hb.hooks.addFunction;
      const removeFunction = this.hb.hooks.removeFunction;
      const utf8Decoder = this.hb.hooks.utf8Decoder;
      const Module = this.hb.hooks.Module;    
      var traceFunc = function(bufferPtr, fontPtr, messagePtr, user_data) {
        return 1;
      }
      var traceFuncPtr = addFunction(traceFunc, 'iiiii');
      exports.hb_buffer_set_message_func(buffer.ptr, traceFuncPtr, 0, 0);
      this.hb.shape(this.font, buffer, this.features);
      removeFunction(traceFuncPtr);
    }
    const json = buffer.json(this.font);
    this.results.json = json;
    let totalAdv = 0;
    this.results.json.forEach(function(g) { totalAdv += g.ax; });
    this.results.totalAdv = totalAdv;
    buffer.destroy();
  }
  shapeWithTraceLimits(txt) {
    if (!this.fontBlob) return;
    var buffer = this.hb.createBuffer();
    buffer.addText(txt);
    buffer.guessSegmentProperties();
    if ((typeof this.script === 'string') && (this.script.length > 0))
      buffer.setScript(this.script || 'latn');
    if ((typeof this.lang === 'string') && (this.lang.length > 0))
      buffer.setLanguage(this.lang);
    let trace = this.hb.shapeWithTraceLimits(this.font, buffer, this.features);
    const json = buffer.json(this.font);
    this.results.json = json;
    let totalAdv = 0;
    this.results.json.forEach(function(g) { totalAdv += g.ax; });
    this.results.totalAdv = totalAdv;
    buffer.destroy();
    return trace;
  }
  compare(hb2, toleranceFunction) {
    // Returns bit field:
    // 1 = GID different
    // 2 = Cluster different
    // 4 = Offset different
    // 8 = Advance different (e.g. kerning)
    // 32 = Overall Advance different
    // 128 = different length
    // 64  = exact
    if (!toleranceFunction) {
      toleranceFunction = function(a,b) {
        return (a !== b);
      }
    }
    if ( (typeof this.results === 'undefined') ||
         (typeof this.results.json === 'undefined') ||
         (typeof hb2.results === 'undefined') ||
         (typeof hb2.results.json === 'undefined')
       )
    {
      return -1;
    }
    var idx = 0;
    var res = 0;
    while (true) {
      if (idx >= this.results.json.length) {
        if (idx < hb2.results.json.length) res |= 128;
        break;
      }
      if (idx >= hb2.results.json.length) {
        res |= 128;
        break;
      }
      const g1 = this.results.json[idx];
      const g2 = hb2.results.json[idx];
      if (g1 === null) {
        if (g1 !== null) res |= 128;
        break;
      }
      if (g2 === null) {
        res |= 128;
        break;
      }
      if (g1.g  !== g2.g)  res |= 1;
      if (g1.cl !== g2.cl) res |= 2;

      if (toleranceFunction(g1.dx, g2.dx)) res |= 4;
      if (toleranceFunction(g1.dy, g2.dy)) res |= 4;
      if (toleranceFunction(g1.ax, g2.ax)) res |= 8;
      if (toleranceFunction(g1.ay, g2.ay)) res |= 8;
      idx++;
    }
    if (toleranceFunction(this.results.totalAdv, hb2.results.totalAdv)) res |= 32;
    if (res === 0) res |= 64;
    return res;
  }
  shapeGlyphCompare(txt) {
    if (!this.gc) return;
    let json = this.gc.shape(txt, this.features);
    this.gc.toPath(json);
  }
  compareOverlap(hb2) {
    if (!this.gc) return undefined;
    if (!hb2.gc) return undefined;
    let overlap = this.gc.overlapArea(hb2.gc);
    return overlap;
  }
  genSVGPath(p64, settings) {
    const size = p64.size();
    for (let i=0;i<size;i++) {
      const point = p64.get(i);
      const x= Number(point.x) *  1;
      const y= Number(point.y) * -1;
      if (i==0)
        this.svgData += `M${x},${y}`;
      else
        this.svgData += `L${x},${y}`;
      point.delete(); //??
    }
    this.svgData += 'z';
  }
  genSVGPaths(ps64, settings) {
    if (!isAssigned(ps64)) return;
    settings = settings || {};
    if (!isExists(settings.mixBlendMode)) settings.mixBlendMode = 'normal';
    this.svgData += '<path ';
    if (settings.id) {
      this.svgData += `id="${settings.id}" `;
    }
    this.svgData += ' style="';
    if (isExists(settings.fillColor)) {
      if (!isExists(settings.fillOpacity)) settings.fillOpacity = 0.5;
      this.svgData += 'fill:'+settings.fillColor
                    +';fill-opacity:'+settings.fillOpacity
    } else {
      this.svgData += ';fill-opacity:0';
    }
    if (isExists(settings.strokeColor)) {
      if (!isExists(settings.strokeOpacity)) settings.strokeOpacity = 1.0;
      if (!isExists(settings.strokeWidth)) settings.strokeWidth = 2;
      this.svgData += ';stroke:'+settings.strokeColor
                    +';stroke-opacity:'+settings.strokeOpacity
                    +';stroke-width:'+settings.strokeWidth
                    +';stroke-linejoin=\'round\''
    }
    if (settings.mixBlendMode !== 'normal')
      this.svgData +=';mix-blend-mode:\''+settings.mixBlendMode+'\''
    
    this.svgData += '" d="';
    const size = ps64.size();
    for (let i=0;i<size;i++) {
      const path = ps64.get(i);
      this.genSVGPath(path, settings);
      path.delete();
    }
    this.svgData += '"/>\r\n';
    return this.svgData;
  }
  genSVGcombined(txt, hb2, hideOverlap, options) {
    const haveThat = hb2.gc;
    this.svgData = '';
    let svg = '';
    if (!this.gc) return '';
    const scale = options?.scale || 100;
    let   width  = Math.round(scale/100.0*(options?.width || 800));
    let   height = Math.round(scale/100.0*(options?.height || 400));
    const xmin      = -250;
    const ymin      = -1800;
    const widthStart = 5700;
    let   svgWidth  = widthStart;
    const margin = 500;

    let jsonThat = undefined;
    let jsonThis = this.gc.shape(txt, this.features);
    if (jsonThis.totalAdv > svgWidth) svgWidth = jsonThis.totalAdv + margin * 2;
    if (hb2.gc) {
      jsonThat = hb2.gc.shape(txt, this.features);
      if (jsonThat.totalAdv > svgWidth) svgWidth = jsonThat.totalAdv + margin * 2;
    }
    width = Math.round(svgWidth / widthStart * width);

    const svgHeight = Math.round(height/width*svgWidth);
    const alignOptions = {
      width:svgWidth + xmin*2,
      align:text_align,
      margin:margin,
    };

    let p64This = this.gc.toPath(jsonThis, alignOptions);
    let fopac = 1.0;
    if (hb2.gc && options.font2) {
      let p64That = hb2.gc.toPath(jsonThat, alignOptions);
      fopac = hideOverlap ? 1.0 : 0.5;
      if (options.font1)
      {
        // Bright highlight differences
        let p64Overlap = this.gc.overlapToCPaths64(hb2.gc);
        svg += this.genSVGPaths(p64Overlap.paths64, {strokeColor:'#2f4', strokeWidth:151, strokeOpacity:0.7, fillColor:'#2f4', fillOpacity:0.1});
        p64Overlap.destroy();
      }
      svg += this.genSVGPaths(p64That.paths64, {fillColor:'#e60', fillOpacity:fopac});
    }
    if (options.font1) {
      svg += this.genSVGPaths(p64This.paths64, {fillColor:'#008', fillOpacity:fopac});
    }

    svg = '<svg xmlns="http://www.w3.org/2000/svg"'
      + ` height="${height}" width="${width}"`
      + ` viewBox="${xmin} ${ymin} ${svgWidth} ${svgHeight}">` +svg+'</svg>'; 
    return svg;
  }
  getGlyphClass(gid) {
    return this.otLayout.getGlyphClass(this.otFont.tables.gdef.classDef, gid);
  }
  isMarkClass(gid) {
    return this.setGidIsMark.has(gid);
    //return (this.getGlyphClass(gid) === 3);
  }
  getGlyphName(gid) {
    const glyphData = this.otFont?.glyphs?.get(gid);
    if (!glyphData) return undefined;
    return glyphData.name;
  }
  getGidFromName(name) {
    if (!this.glyphNameToGid) return;
    return this.glyphNameToGid.get(name);
  }
  getGposTableName(idx) {
    if (!this.debugInfo) return null;
    const gpos = this.debugInfo['GPOS'];
    if (!gpos || (gpos.length == 0)) return null;
    const debugData = gpos[idx];
    if (!debugData) return null;
    return debugData[1];
  }
  findGposIndexesFromRegExpList(regExpList) {
    if (!regExpList) return null;
    if (regExpList.length == 0) return null;

    let set = new Set();
    if (this.debugInfo) {
      const gpos = this.debugInfo['GPOS'];
      if (!gpos || (gpos.length == 0)) return null;
      for (const [key,dd] of Object.entries(gpos)) {
        const name = dd[1];
        const keyInt = parseInt(key);
        for (let j=0; j<regExpList.length; j++) {
          const re = regExpList[j];
          if (typeof re === 'object') {
            if (re.test(name)) {
              set.add(keyInt);
              break;
            }
            if (re.test(key)) {
              set.add(keyInt);
              break;
            }
          } else {
            // Numbers handle separately
          }
        }
      }
    }
    // Handle numeric GPOS table entries separately
    for (let j=0; j<regExpList.length; j++) {
      const re = regExpList[j];
      if (typeof re === 'number') {
        set.add(re);
      }
    }
    return set;
  }
  findGidIndexesFromRegExpList(regExpList) {
    if (!regExpList) return null;
    if (regExpList.length == 0) return null;
    let set = new Set();
    const max = this.otFont?.glyphs?.length;
    if (!max) return null;
    for (let gid=0; gid<max; gid++) {
      const name = this.getGlyphName(gid);
      const gidString = String(gid);
      for (let j=0; j<regExpList.length; j++) {
        const re = regExpList[j];
        if (typeof re === 'object') {
          if (re.test(name)) {
            set.add(gid);
            break;
          }
          if (re.test(gidString)) {
            set.add(gid);
            break;
          }
        } else
        if (typeof re === 'number') {
          if (re == gid) {
            set.add(gid);
            break;
          }
        }
      }
    }
    return set;
  }
}

var hbf1 = new hbFont;
var hbf2 = new hbFont;

function setHarfBuzzFontObjects(hb1, hb2) {
  hbf1.setHarfBuzz(hb1);
  hbf2.setHarfBuzz(hb2);
}

//--v--v--v-- CoPilot Code


/**
 * Longest Common Subsequence with gap constraints.
 *
 * @param {Array} A
 * @param {Array} B
 * @param {Object} opts
 * @param {number} opts.maxGapA - max allowed gap in A between matched elements
 * @param {number} opts.maxGapB - max allowed gap in B between matched elements
 * @param {Function} opts.equals - comparator (a, b) => boolean
 *
 * @returns {Array} the constrained LCS
 */
function lcsWithGapConstraints(A, B, opts = {}) {
  const maxGapA = opts.maxGapA ?? Infinity;
  const maxGapB = opts.maxGapB ?? Infinity;
  const equals = opts.equals ?? ((x, y) => x === y);

  const n = A.length;
  const m = B.length;

  // DP[i][j] = best LCS ending at A[i], B[j]
  const DP = Array.from({ length: n }, () =>
    Array.from({ length: m }, () => ({
      length: 0,
      prev: null
    }))
  );

  let best = { length: 0, i: -1, j: -1 };

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (!equals(A[i], B[j])) continue;

      // Start a new subsequence
      DP[i][j].length = 1;

      // Try to extend from previous matches
      for (let pi = Math.max(0, i - maxGapA - 1); pi < i; pi++) {
        for (let pj = Math.max(0, j - maxGapB - 1); pj < j; pj++) {
          if (DP[pi][pj].length + 1 > DP[i][j].length) {
            DP[i][j].length = DP[pi][pj].length + 1;
            DP[i][j].prev = [pi, pj];
          }
        }
      }

      // Track global best
      if (DP[i][j].length > best.length) {
        best = { length: DP[i][j].length, i, j };
      }
    }
  }

  // Reconstruct LCS
  const result = [];
  let cur = best.i >= 0 ? [best.i, best.j] : null;

  while (cur) {
    const [i, j] = cur;
    result.push(A[i]);
    cur = DP[i][j].prev;
  }

  return result.reverse();
}
//--^--^--^--

// WARNING: this is a fragile extraction.
//          If Font Force Field outputs different info, this will fail.
function splitInfoToGlyphs(txt) {
  if (!txt) return;
  const glyphs = txt.startsWith('"')?txt.match(/"‚Üê?\s*([^"]+)"/u):txt.match(/‚Üê?\s*([^"]+)/u);
  const ic = [];
  ic.worst = {
    index: 0,
    value: 99, // Yuck
  };
  ic.rtl = txt.includes('‚Üê');
  if (glyphs && glyphs[1]) {
    const glyphsTxt = glyphs[1].trim();
    const arr = glyphsTxt.split(' ');
    arr.forEach(function(g, idx) {
      if (!g) return;
      const m = g.match(/‚Ü≥?([üü•üüßüü™üü¶üü¢üü°]*)([^\s]+)/u); // ignore marker point
      if (!m) return;
      const icons = m[1];
      if (icons) {
        for (let i=0;i<icons.length;i+=2) {
          const iio = iconsOrder.indexOf(icons.substr(i,2));
          if (iio < ic.worst.value) {
            ic.worst.value = iio;
            ic.worst.index = idx;
          }
        }
      }
      const seq = m[2];      
      const gid = hbf1.getGidFromName(seq);
      const mark = gid? hbf1.isMarkClass(gid):undefined;
      ic.push({
        idx: idx,
        icons: icons,
        glyph: seq,
        gid: gid,
        mark: mark,
      });
    });
  }
  return ic;
}

function searchDP(searchText, options) {
  const minLength = options?.minLength || 2;
  const ts = Date.now();
  const result = [];
  const max = wordList.length;
  const sarr = splitInfoToGlyphs(searchText);
  options.equals = function(a,b) {
    return (a.glyph === b.glyph);
  }
  for (let i=0; i<max; i++) {
    const r = lcsWithGapConstraints(wordList[i].infoCache(), sarr, options);
    if (r.length >= minLength) {
      result.push({
        word: wordList[i].getWord(),
        res : r,
        glyphs: wordList[i].infoCache(),       
        wordEntry: wordList[i], 
      });
    }
  }
  const te = Date.now();
  if (options.sortByLength) {
    result.sort(function(a,b) {
      const aa = a.res;
      const ba = b.res;
      if (aa.length > ba.length) return -1;
      if (aa.length < ba.length) return  1;
      for (let i=0; i<aa.length; i++) {
        if (aa[i] > ba[i]) return 1;
        if (aa[i] < ba[i]) return -1;
      }
      if (a.word > b.word) return 1;
      if (a.word < b.word) return -1;
      return 0;
    });
  }
  //~~//console.log('searchDP', wordList.length, te-ts, result);//~~
  return result;
}

//~~~~
function testDP() {

  function eq(a,b) {
    return a.glyph === b.glyph;
  }


  const a1 = splitInfoToGlyphs('‚Üê üü•üü™ALIFu1 üü¶MADDA BEi16 üü¶sda üü•üü™KASRA REf1');
  //const a2 = splitInfoToGlyphs('TOEi15 VAOf1 FEi3 sda ALIFf1 NUNu1 sdi KASRA space REu1 FATHA AINi3 DALf1 VAOu1 BEi16 sdb.one REf1 QAFu1 dda');
  const a2 = splitInfoToGlyphs('sda REf1 NUNu1 sdb KASRA REf1 BEi16 sdb sda sdb REf1 QAFu1 dda');

  console.log(lcsWithGapConstraints(a1, a2, {
    maxGapA: 2,
    maxGapB: 2,
    equals: eq,
  }));
}

let patternResults = [];

async function patternMatchFind() {
  const searchText = txtPatternMatchText.value;
  const options = {
    minLength: parseInt(txtMinMatch.value, 10),
    maxGapA: parseInt(txtMaxGap.value, 10),
    maxGapB: parseInt(txtMaxGap.value, 10),
    sortByLength: cbPatternSortLength.checked,
  };
  const result = searchDP(searchText, options); 
  // Copy to clipboard as a test...
  let txt = `# SEARCH PATTERN: ${searchText}<br/>\r\n<br/>\r\n`;
  //txt += 'Index\tWord\tMatchLength\tInfo\tResult\r\n';
  //txt += 'Word \tInfo \tGlyphCount \tGlyphsMatched<br/>\r\n';
  txt += 'Word \tInfo \tGlyphCount<br/>\r\n';
  patternResults.length = 0;
  result.forEach((entry, index) => {
    const matched = entry.res.join(' ');
    //txt += `${index+1}\t${entry.word}\t${entry.res.length}\t${entry.wordEntry.getInfo()}\t${matched}\r\n`
    let glyphs = '"';
    let im=0;
    const ic = entry.wordEntry.infoCache();
    patternResults.push(entry);
    if (ic.rtl) glyphs += `‚Üê `;
    ic.forEach((e)=> {
      let highlight = false;
      if (im<entry.res.length) {
        // NOTE: for this to work, the first term to the LCS function must be the word
        //       and the second term must the item to search for.
        if (entry.res[im].idx === e.idx) {
          highlight = true;
          im++;
        }
      }
      glyphs += e.icons;
      if (highlight)
        glyphs += `<span class='HiLite'>${e.glyph}</span> `;
      else
        glyphs += `${e.glyph} `;
    });
    glyphs = glyphs.trim() + '"';

    //txt += `${entry.word} \t${entry.wordEntry.getInfo()} \t${entry.res.length} \t${matched}<br/>\r\n`
    txt += `${entry.word} \t${glyphs} \t${entry.res.length}<br/>\r\n`
  });
  //taPatternOutput.value = txt;
  divPatternOutput.innerHTML = txt;
  divPatternResults.innerHTML = `Found ${result.length}`;
}

async function copyPatternResultsToClipboard() {
  //let txt = divPatternOutput.innerHTML;
  //txt = txt.replace(/<br\/?>/g, '');
  const txt = divPatternOutput.textContent;
  navigator.clipboard.writeText(txt);
}

function patternResultsCheckmark() {
  patternResults.forEach((e)=>e.wordEntry.setChecked(true));
  window.alert(`Checked ${patternResults.length} words`);
  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
}

class wordEntryClass {
  constructor(line) {
    const tempArray = line.split('\t');
    this.word = tempArray[0];
    this.note = tempArray[1] || '';
    //this.diff = tempArray[2] || '';
    this.diff = '';
    this.info = tempArray.slice(2).join('\t');
    this.checked = false;
    //??//this.checked = (tempArray[2] === 'x') || (tempArray[2] === 'X'); //??
  }
  getWord()     { return this.word; }
  getChecked()  { return this.checked; }
  setChecked(isChecked) { this.checked = isChecked; }
  setNote(txt)  { this.note = txt; }
  getNote()     { return this.note; }
  getInfo()     { return this.info; }
  setInfo(txt)  { 
    if (this.info != txt) this.infoCacheClear();
    this.info = txt;
  }
  infoCacheClear() { delete this.infoCache; }
  infoCache() {    
    // Build the cache array for pattern matching and sorting etc
    if (this._infoCache) return this._infoCache;
    const txt = this.info;
    this._infoCache = splitInfoToGlyphs(txt);
    return this._infoCache;
  }
  getWorst() {
    return this.infoCache().worst;
  }
  _compareInfoFrom(idxThis, that, idxThat) {
    const icThis = this.infoCache();
    const icThat = that.infoCache();
    while (idxThis < icThis.length) {
      if (idxThat >= icThat.length) return 1;
      const gThis = icThis[idxThis];
      const gThat = icThat[idxThat];
      if (gThis.glyph > gThat.glyph) return 1;
      if (gThis.glyph < gThat.glyph) return -1;
      idxThis++;
      idxThat++;
    }
    if (idxThat < icThat.length) return -1;
    return 0;    
  }
  compareInfoWorst(that) {
    const wThis = this.getWorst();
    const wThat = that.getWorst();

    // Compare the severity (lower comes first)
    if (wThis.value < wThat.value) return -1;
    if (wThis.value > wThat.value) return  1;

    // Same value... now need to compare glyphs from the index points forwards
    let idxThis = wThis.index;
    let idxThat = wThat.index;

    return this._compareInfoFrom(idxThis, that, idxThat);
  }
  getDiff()     { return this.diff; }
  setDiff(diff) { this.diff = diffValueToUnicode(diff); }
  setGposData(gpd) { this.gposData = gpd; }
  getGposData() { return this.gposData; }
  setGidData(gids) { this.gidData = gids; }
  getGidData() { return this.gidData; }
  // The line for the check list file output
  getLine() {
    var txt = this.word + 
        '\t' + (this.note || '') + 
        //'\t' + (this.diff || '') +
        '\t' + (this.info || '');
    while (txt.endsWith('\t')) {
      txt = txt.slice(0, txt.length-1);
    }
    return txt;
  }
  updateDifferenceIcons(diffs) {
    // remove icons first...
    // and append
    this.note = diffValueToNote(this.note, diffs);
  }
  cacheClear() {
    delete this.area;
    delete this.diffArea;
    delete this.gposData;
    delete this.gidData;
    delete this.gidSeq;
  }
  calcDifferenceArea(hbf1, hbf2) {
    hbf1.shapeGlyphCompare(this.word);
    hbf2.shapeGlyphCompare(this.word);
    let da = 0;
    let diffs = hbf1.compareOverlap(hbf2);
    if (diffs) da = Math.round(diffs.fill) / 1000.0;
    this.diffArea = da;
    if (hbf1.gc && hbf2.gc) {
      this.area = [];
      this.area[1] = hbf1.gc.getArea();
      this.area[2] = hbf2.gc.getArea();
      this.area[0] = (this.area[1] - this.area[2]) / this.area[1]; // Ratio
      this.totalAdv = [];
      this.totalAdv[1] = hbf1.results.totalAdv;
      this.totalAdv[2] = hbf2.results.totalAdv;
      this.totalAdv[0] = differenceRatio(hbf1.results.totalAdv, hbf2.results.totalAdv);
    }
    return da;
  }
  getDifferenceArea() { return this.diffArea; }
  getDifferenceAreaCalc(hbf1, hbf2) {
    if (typeof this.diffArea !== 'undefined') return this.diffArea;
    return this.calcDifferenceArea(hbf1, hbf2);
  }
  updateGids(hbo) {
    if (this.gidData) return;
    const json = hbo.results.json;
    if (!json) return;
    let gids = new Set();
    let gidSeq = [];
    for (let idx=0; idx<json.length; idx++) {
      const x = json[idx];
      gids.add(x.g);
      gidSeq.push(x.g);
    }
    this.gidData = gids;
    this.gidSeq = gidSeq;
  }
}

var wordList = []; // An array of wordEntry objects

function fontsHaveChanged() {
  const size = wordList.length;
  for (let i=0; i<size; i++) {
    wordList[i].cacheClear();
  }
}

function checkWhetherClearCache() {
  if (!window.confirm('Clear the word list HarfBuzz cache?')) return;
  fontsHaveChanged();
}

function buildListFromFileContents(txt)
{
  var lines = txt.split(/\r?\n+/g);
  var tempWordList = [];  // Start empty
  var i = 0;
  while (i < lines.length) {
    const wordEntry = new wordEntryClass(lines[i]);
    if (wordEntry.getWord().length > 0) {
      tempWordList.push(wordEntry);
    }
    i++;
  }
  return tempWordList;
}

function getWordCheckCount() {
  var count = 0;
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) count++;
    i++;
  }
  return count;
}

function findWordInList(theList, theWord, cache)
{
  if (cache === undefined) {
    var i = 0;
    while (i < theList.length) {
      if (theList[i].getWord() === theWord) {
        return i;
      }
      i++;
    }
    return -1;
  }
  if (!cache._filled) {
    const size = theList.length;
    for (let i=0; i<size; i++) {
      const word = theList[i].getWord();
      if (!cache[word])
        cache[word] = i;
    }
    cache._filled = true;
  }
  const ce = cache[theWord];
  if (ce === undefined)
    return -1;
  return ce;
}

function addToList(theList, wordListEntry, cache) {
  theList.push(wordListEntry);
  cache[wordListEntry.getWord()] = theList.length - 1;
} 

function updateCheckListCount() {
  var count = getWordCheckCount();
  CheckListCount.innerHTML = 'Checked '+count+'/'+wordList.length;
}

function checkBothFontsLoaded() {
  var res = true;
  if (!hbf1.fileDescription) res = false;
  if (!hbf2.fileDescription) res = false;
  if (hbf1.fileDescription === '') res = false;
  if (hbf2.fileDescription === '') res = false;
  //allow comparing debug & reuglar//if (hbf1.fileDescription === hbf2.fileDescription) res = false;
  if (!res)
  {
    window.alert('Please load two fonts to compare');
  }
  return res;
}

/*
function showHideColumn(colNo, doShow) {
  var stl;
  if (doShow)
    stl = 'table-cell';
  else
    stl = 'none';
  const rows = word_list.getElementsByTagName('tr');
  const size = rows.length;
  for (let row=1; row<size; row++) {
    const cells = rows[row].getElementsByTagName('td');
    cells[colNo].style.display = stl;
  }
}
*/

function showFontTwo(doShow) {
  if (doShow) {
    checkListHeading.style.width = '16%';
    // diff = '6%'
    fontOneInfo.style.width = '26%';
    fontTwoInfoCell.style.width = '26%';
    //showHideColumn(3, true);
    //showHideColumn(4, true);
  } else {
    checkListHeading.style.width = '39%';
    // diff = '6%'
    fontOneInfo.style.width = '40%';
    fontTwoInfoCell.style.width = '10%';
    //showHideColumn(3, false);
    //showHideColumn(4, false);
  }
  doShowFontTwo = doShow;
  updateListByField();
}

function toggleVisibilityLabel(ele, href) {
  ele.hidden = !ele.hidden;
  let txt = href.text;
  if (ele.hidden)
    href.text = txt.replace('Hide', 'Show');
  else
    href.text = txt.replace('Show', 'Hide');
}

function toggleHBIcons() {
  HBIcons.innerHTML = '<p align="left">'+
    hb_icons.identical[0] + 'exact</br>'+
    //hb_icons.gid[0]       + 'gids</br>'+
    hb_icons.count[0]     + 'count</br>'+
    hb_icons.cluster[0]   + 'clu</br>'+
    hb_icons.advance[0]   + 'adv</br>'+
    hb_icons.offset[0]    + 'ofs</br>'+
    hb_icons.total[0]     + 'tot</br>'+
    "</span>";
  HBIcons.hidden = !HBIcons.hidden;
}

function triCb(cb) {
  if (cb.readOnly) cb.checked=cb.readOnly=false;
  else if (!cb.checked) cb.readOnly=cb.indeterminate=true;
}

function iterateGtable(gtable, theKey, outputset) {
  if (!gtable) return;
  const scriptTable = gtable.scriptTable;
  if (!scriptTable) return;
  if (!scriptTable[theKey]) return;
  for (const y of scriptTable[theKey]) {
    outputset.add(y);
  }
}

function mapToQuotes(list) {
  return '"'+[...list].sort().join('","')+'"';
}

function getScriptLanguage(fontInfo, filterScript) {
  let scripts = '';
  let languages = '';
  if (fontInfo) {
    if (fontInfo.scripts.size > 0)
      scripts = mapToQuotes(fontInfo.scripts);

    let languageSet = fontInfo.languages;
    if (filterScript !== '') {
      filterScript = filterScript.toLowerCase();
      languageSet = new Set();
      iterateGtable(fontInfo.GSUB, filterScript, languageSet);
      iterateGtable(fontInfo.GPOS, filterScript, languageSet);
    }
    if (languageSet.size > 0)
      languages = mapToQuotes(languageSet);
  }
  return {
    scripts: scripts,
    languages: languages,
  };
}

// Update the document language tag, and the HarfBuzz values
function updateLanguage() {
  const script = inputScript.value;
  const language = inputLanguage.value;

  inputScriptList.innerText = '(empty)';
  inputLanguageList.innerText = '(empty)';

  const details1 = getScriptLanguage(hbf1.fontInfo, script);
  const details2 = getScriptLanguage(hbf2.fontInfo, script);
  let scripts = details1.scripts;
  if (scripts === '') {
    scripts = details2.scripts;
    if (scripts !== '') scripts = 'FONT2: '+scripts;
  }
  if ((details2.scripts !== '') && (details2.scripts !== details1.scripts)) {
    scripts = 'FONT1: '+details1.scripts + '\r\n'+ 'FONT2: '+details2.scripts;
  }
  if (scripts !== '') inputScriptList.innerText = scripts;

  let languages = details1.languages;
  if (languages === '') {
    languages = details2.languages;
    if (languages !== '') languages = 'FONT2: '+languages;
  }
  if ((details2.languages !== '') && (details2.languages !== details1.languages)) {
    languages = 'FONT1: '+details1.languages + '\r\n' + 'FONT2: '+details2.languages;
  }
  if (languages !== '') inputLanguageList.innerText = languages;

  // TODO: FEATURES

  document.documentElement.setAttribute('lang', HTMLLang.value);
  updateHarfBuzzScriptLanguage();
}

function ClearCheckList() {
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(false);
    i++;
  }
  resetCheckListChanged();
}

function ClearCheckListUser(e) {
  elementHidePopover(e);
  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Clear all?')) return;
  }
  ClearCheckList();
  updateCheckListCount();
  updateListByField();
}

function CheckAllList(e) {
  elementHidePopover(e);
  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Set all?')) return;
  }
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(true);
    i++;
  }
  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
}

function InvertCheckList(e) {
  elementHidePopover(e);
  const size = wordList.length;
  for (let i=0; i<size; i++) {
    wordList[i].setChecked(!wordList[i].getChecked());
  }
  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
}

function GetRadioValue(id) {
  const radios = document.getElementsByName(id);
  for (var i=0, rl=radios.length; i<rl; i++) {
    if (radios[i].checked) {
      return radios[i].value;
    }
  }
  return null;
}

function findInExpList(expList, value) {
  for (let i=0; i<expList.length; i++) {
    const re = expList[i];
    if (re.test(value)) return true;
  }
  return false;
}

function createRegExp(txt) {
  if (!txt || (txt === '')) return null;
  try {
    re = new RegExp(txt);
  } catch (e) {
    window.alert(e.message);
    return null;
  }
  return re;
}

function createRegExpList(txt) {
  if (!txt || (txt === '')) return null;
  const txtList = txt.split(',');
  const expList = [];
  const isInteger = new RegExp('^[0-9]+$');
  for (let i=0; i<txtList.length; i++) {
    const entry = txtList[i];
    if (isInteger.test(entry)) {
      expList.push(parseInt(entry));
    } else {
      try {
        expList.push( new RegExp(entry) );
      } catch (e) {
        window.alert(e.message);
        return null;
      }
    }
  }
  return expList;
}

function isHarfBuzzMessageImportant(msg) {
  const set = [
    // GSUB operations
    'replacing',   'replaced',
    'deleting',    'deleted',
    'multiplying', 'multiplied',
    'ligating',    'ligated',

    // GPOS operations
    'kerning',     'kerned',
    'attaching',   'attached',
    'positioning', 'positioned',
  ];
  const size = set.length;
  for (let i=0;i<size;i++) {
    if (msg.includes(set[i])) return true;
  }
  return false;
}

function isHarfBuzzMessageAnAction(msg) {
  const set = [
    // GSUB operations
    'replaced',
    'deleted',
    'multiplied',
    'ligated',

    // GPOS operations
    'kerned',
    'attached',
    'positioned',
  ];
  const size = set.length;
  for (let i=0;i<size;i++) {
    if (msg.includes(set[i])) return true;
  }
  return false;
}

function findLastLookup(trace, index) {
  let res = {};
  if (index >= trace.gpos_point) res.stage = 'GPOS';
  else if (index >= trace.gsub_point) res.stage = 'GSUB';
  while (!res.lastIndex && (index > 0)) {
    let debugInfo = null;
    const message = trace[index].m;
    const m3 = message.match(/^start lookup (\d+) feature '(\w+)'/);
    const m4 = message.match(/^recursing to lookup (\d+)/);
    if (m3) {
      res.lastIndex = parseInt(m3[1], 10);
    }
    if (m4) {
      res.lastIndex = parseInt(m4[1], 10);
    }
    index--;
  }
  res.index = index;
  return res;
}

function extractGposData(trace) {
  if (!trace || !trace.gpos_point) return null;
  let idx = trace.gpos_point;
  let gposTable;
  const max = trace.length;
  const res = [];
  const stack = [];
  while (idx < max) {
    const tr = trace[idx];
    const msg = tr?.m;
    const m3 = msg.match(/^start lookup (\d+) feature '(\w+)'/);
    const m3e = msg.match(/^end lookup (\d+) feature '(\w+)'/);
    const m4 = msg.match(/^recursing to lookup (\d+)/);
    const m4e = msg.match(/^recursed to lookup (\d+)/);
    if (m3) { 
      gposTable = parseInt(m3[1], 10);
      stack.push(gposTable);
    }
    if (m4) {
      gposTable = parseInt(m4[1], 10);
      stack.push(gposTable);
    }
    if (m3e) {
      stack.pop();
    }
    if (m4e) {
      stack.pop();
    }

    if (isHarfBuzzMessageAnAction(msg)) {
      //~~//console.log('gpos', idx, msg, m3, m4, gposTable); //~~
    }
    if (!m3 && !m4) {
      // Pull out glyph index figures to establish which GIDs affected
      // Scan for ' at ...' in the tr.m field
      var sets = msg.match(/ glyphs? at [\d,]+,?[\d]*/g);
      if (sets) {
        for (let ti=stack.length-1;ti>=0;ti--) {
          const tn = stack[ti];
          if (!res[tn]) {
            res[tn] = new Set();
            res[tn].depth = new Set();
          }
        }
        let i = 0;
        while (i < sets.length) {
          const indices = sets[i].match(/\d+/g);
          let j = 0;
          while (j < indices.length) {
            const n = parseInt(indices[j], 10);
            const gid = tr?.t[n]?.g;
            for (let ti=stack.length-1; ti>=0; ti--) {
              const tn = stack[ti];
              res[tn].add(gid);
              res[tn].depth.add(stack.length - ti - 1);
            }
            j++;
          }
          i++;
        }
      }
    }
    idx++;
  }
  return res;
}

// Build array of [GID][GPOS] = count
function addToGposGrid(grid, gposData, phrase) {
  if (!gposData) return;
  if (!grid.gpos) grid.gpos = []; // A list of all the GIDs in the output
  if (!grid.gids) grid.gids = [];
  if (!grid.gposDepths) grid.gposDepths = [];
  gposData.forEach( function(item, gposIndex) {
    if (!grid.gpos[gposIndex]) grid.gpos[gposIndex] = 0;
    grid.gpos[gposIndex]++;
    if (!grid.gposDepths[gposIndex]) grid.gposDepths[gposIndex] = new Set();
    grid.gposDepths[gposIndex] = grid.gposDepths[gposIndex].union(item.depth);

    item.forEach( function(item) {
      if (!grid.gids[item]) grid.gids[item] = 0;
      grid.gids[item]++;

      if (!grid[item]) grid[item] = [];
      if (!grid[item][gposIndex]) grid[item][gposIndex] = 0;
      grid[item][gposIndex]++;
    });
  });
  return grid;
}

function setToArraySortedNumerically(s) {
  const res = Array.from(s);
  res.sort( (a,b) => {
    const ai = parseInt(a, 10);
    const bi = parseInt(b, 10);
    return ai - bi;
  });
  return res;
}

async function processChecklistGpos(e) {
  elementHidePopover(e);
  const size = wordList.length;
  let et = new ElapsedTimer();
  gposGrid = [];
  window.gposGrid = gposGrid;
  let count = 0;
  let aborted = false;

  startLongRunning();
  startTheLoop();
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    if (we.getChecked()) {
      const phrase = we.getWord();
      if (!we.getGposData()) {
        let trace = hbf1.shapeWithTraceLimits(phrase);
        we.updateGids(hbf1);
        we.setGposData(extractGposData(trace));
      }
      addToGposGrid(gposGrid, we.getGposData(), phrase);
      count++;
    }
    if (et.elapsed()) {
      updateStatusMessage(i, 0, size);
      //mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      aborted = true;
      break;
    }
  } 
  doneLongRunning();

  if (aborted) return;
  if (!count) {
    window.alert('Nothing checked!');
    return;
  }

  let html = 'GID/GPOS analytics\r\n\r\n';

  const gposSet = gposGrid.gpos;
  const gidSet  = gposGrid.gids;
  const gposDepths = gposGrid.gposDepths;
  if (!gposSet) return;
  html += '"GID","GlyphName"';
  gposSet.forEach( function(item, gpos) {
    const gposName = hbf1.getGposTableName(gpos);
    if (gposName)
      html += `,"${gpos}:${gposName}"`;
    else
      html += `,${gpos}`;
  });
  html += `,"TOTAL"`;
  html += '\r\n';

  html += `"","(Depth)"`;  
  gposSet.forEach( function(item, gpos) {
    const gposDepth = setToArraySortedNumerically(gposDepths[gpos]);
    let txt = '';
    gposDepth.forEach( (i) => {
      txt += `${i},`;
    });
    txt = txt.slice(0, -1);
    html += `,"${txt}"`;
  });
  html += `,`;
  html += '\r\n';

  gposGrid.forEach( function(gidItem, gid) {
    const gidName = hbf1.getGlyphName(gid);
    html += `${gid}`;
    if (gidName)
      html += `,"${gidName}"`;
    else
      html += `,`;

    gposSet.forEach( function(gposItem, gpos) {
      const gidCount = gidItem[gpos];
      if (gidCount)
        html += `,${gidCount}`;
      else
        html += `,`;
    });

    html += `,${gposGrid.gids[gid]}`;
    html += '\r\n';
  });

  html += '"TOTAL",';
  gposSet.forEach( function(item, gpos) {
    html += `,${item}`;
  });
  html += '\r\n';

  // Add the Font Details
  html += '\r\n';
  html += `"FONT","${hbf1.fontNames.fullName}","${hbf1.fontNames.version},"HarfBuzz ${hbf1.hbVersion}"`;

  // Add the Word List stats
  html += '\r\n';
  html += `"WORDLIST",${wordlist_filename}\r\n`;
  html += `"CHECKED",${getWordCheckCount()}`;

  html += '\r\n\r\n';
  // Sorted outputs for GID and GPOS
  let arr = [];

  html += '"----------------"\r\n';
  html += '"GPOS Count Order"\r\n';
  html += '"----------------"\r\n';
  html += '"GPOS","TableName","Depths","Count"\r\n';
  gposSet.forEach((v,k)=> arr.push({key:k, val:v}));
  arr.sort((a,b) => {
    if (a.val > b.val) return -1;
    if (a.val < b.val) return 1;
    if (a.key > b.key) return 1;
    if (a.key < b.key) return -1;
    return 0;
  });
  arr.forEach((v) => {
    html += `${v.key},`;
    const gposName = hbf1.getGposTableName(v.key);
    if (gposName)
      html += `"${gposName}"`;
    const gposDepth = setToArraySortedNumerically(gposDepths[v.key]);
    let txt = '';
    gposDepth.forEach( (i) => {
      txt += `${i},`;
    });
    txt = txt.slice(0, -1);
    html += `,"${txt}",${v.val}\r\n`;
  });
  html += '\r\n';

  html += '"---------------"\r\n';
  html += '"GID Count Order"\r\n';
  html += '"---------------"\r\n';
  html += '"GID","GlyphName","Count"\r\n';
  arr = [];
  gidSet.forEach((v,k) => arr.push({key:k, val:v}));
  arr.sort((a,b) => {
    if (a.val > b.val) return -1;
    if (a.val < b.val) return 1;
    if (a.key > b.key) return 1;
    if (a.key < b.key) return -1;
    return 0;
  });
  arr.forEach((v) => {
    html += `${v.key},`;
    const gidName = hbf1.getGlyphName(v.key);
    if (gidName)
      html += `"${gidName}"`;
    html += `,${v.val}\r\n`;
  });
  html += '\r\n';

  saveTextToFile(html, 'Glyph-GPOS-Analytics.'+DateTimeForFilename()+'.txt');
}

//const ffftIconsString = '[üü•üüßüü™üü¶üü¢üü°]';
//const ffftIconsRE = new RegExp(ffftIconsString, 'ug');

async function CheckmarkRegExp() {
  // Glyph Name or GPOS table name
  const opType = GetRadioValue('regExpOp');
  const opCheck   = (opType === 'check');
  const opUncheck = (opType === 'uncheck');
  const opInvert  = (opType === 'invert');

  var count = 0;
  const size = wordList.length;
  let et = new ElapsedTimer();

  const expNote = createRegExp(regExpNotes.value);
  const reNoIcons = new RegExp(txtNoIcons.value, 'ug');
  const infoRE = (cbInfoNoIcons.checked) ? reNoIcons : undefined;
  const infoSearchTerm = infoRE ? regExpInfo.value.replace(infoRE, '') : regExpInfo.value;
  const expInfo = createRegExp(infoSearchTerm);
  const expWord = createRegExp(regExpWord.value);
  const glyphChunk = regExpGlyph.value.split('||');  
  const gidSet = [];
  glyphChunk.forEach((v,i) => {
    const expListGlyph = createRegExpList(v);
    const set = hbf1.findGidIndexesFromRegExpList(expListGlyph);
    if (set) gidSet[i] = set;
  });

  const expListGpos  = createRegExpList(regExpGpos.value);
  const gposSet = hbf1.findGposIndexesFromRegExpList(expListGpos);

  if (!expNote && !expInfo && !expWord && !gidSet[0] && !gposSet) {
    window.alert('Please fill in at least one field!');
    return;
  }

  startLongRunning();
  startTheLoop();
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    const phrase = we.getWord();
    let match = true;

    if (match && expNote) match = expNote.test(we.getNote());
    if (match && expWord) match = expWord.test(phrase);
    if (match && expInfo) {
      let info = we.getInfo();
      if (infoRE) info = info.replace(infoRE, '');
      match = expInfo.test(info);
    }

    let trace = null;

    if (match && ((gidSet.length>0) || gposSet)) {
      if (!gposSet) {
        // Straight shape to get gids
        if (!we.getGidData()) {
          hbf1.shape(phrase)
          we.updateGids(hbf1);
        }
      } else {
        // Full trace to extract GPOS table data as well as gids
        if (!we.getGposData()) {
          trace = hbf1.shapeWithTraceLimits(phrase);
          we.updateGids(hbf1);
          we.setGposData(extractGposData(trace));
        }
      }

      if (match && (gidSet.length>0)) {
        // Check whether the glyphs name(s) or number(s) appear in the shaped output
        const gids = we.gidSeq; // Use the sequence
        let matchesGlyph = false;
        gids.forEach( function(key, idx) {
          if (!matchesGlyph && gidSet[0].has(key)) {
            // Check all subsequent for a match
            matchesGlyph = true;
            for (let gi=1;gi<gidSet.length;gi++) {
              if (!gidSet[gi].has(gids[idx+gi])) {
                matchesGlyph = false;
                break;
              }
            }
          }
        });
        if (!matchesGlyph) match = false;
      }

      if (match && gposSet) {
        // Search for GPOS table that had an effect on the output that is in expListGpos
        let matchesGpos = false;
        const gposData = we.getGposData();
        gposData.forEach( function(item, index) {
          if (gposSet.has(index)) {
            matchesGpos = true;
          }
        });
        if (!matchesGpos) match = false;
      }
    }

    if (match) {
      count++;
      if (opCheck)
        we.setChecked(true);
      else if (opUncheck)
        we.setChecked(false);
      else if (opInvert)
        we.setChecked(!we.getChecked());
    }

    if (et.elapsed()) {
      updateStatusMessage(i, count, size);
      //mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      break;
    }
  }

  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
  doneLongRunning();
  window.alert('Found '+count+' matches');
}

var AbortLongRunning = false;

function startLongRunning() {
  AbortLongRunning = false;
  AbortButton.hidden = false;
  ddProgress.style.display = 'block';
}

function doAbortLongRunning() {
  AbortLongRunning = true;
}

function doneLongRunning() {
  AbortButton.hidden = true;
  ddProgress.style.display = '';
}

function isLongRunning() {
  return !AbortButton.hidden;
}

// polyfill for scheduler.yield
globalThis.scheduler = globalThis.scheduler || {};
globalThis.scheduler.yield = 
  globalThis.scheduler.yield || 
  (() => new Promise((r) => setTimeout(r, 0)));

class ElapsedTimer {
  constructor(t=32) {
    this.max = t;
    this.next = performance.now() + t;
  }
  elapsed() {
    const now = performance.now();
    if (now < this.next) return false;
    while (now > this.next) this.next += this.max;
    return true;
  }
}

var loopStarted;

function secondsToHHMMSS(t) {
  if (t < 3600)
    return new Date(t * 1000).toISOString().substring(14, 19);
  else
    return new Date(t * 1000).toISOString().substring(11, 16);
}

function startTheLoop() {
  loopStarted = Date.now();
}

function updateStatusMessage(i, foundCount, total) {
  const overallTime = (Date.now() - loopStarted) / 1000.0;
  let rateWords;
  if (i < 0)
    rateWords = Math.round(total / overallTime);
  else
    rateWords = Math.round(i / overallTime);
  let eta = (total - i) / rateWords;

  if (i <= 0)
    statusUpdate.innerHTML = '-';
  else {
    let html = `<progress max='${total}' value='${i}'></progress><br/><span><font color='red'>${i}/${total}</font>`;
    html += `<br/>${secondsToHHMMSS(overallTime)}/${secondsToHHMMSS(eta)} (${rateWords}/s)</span>`
    if (foundCount > 0) {
      html += '<br/>'+foundCount + ' found';
    }
    statusUpdate.innerHTML = html;
  }
}

function updateBitCountsOne(t, bits, v) {
  if ((bits & v) !== 0) {
    t[v] = (t[v] || 0) + 1;
  }
}

function updateBitCounts(t, bits) {
  updateBitCountsOne(t,bits,hb_icons.count[2]);
  updateBitCountsOne(t,bits,hb_icons.cluster[2]);
  updateBitCountsOne(t,bits,hb_icons.advance[2]);
  updateBitCountsOne(t,bits,hb_icons.offset[2]);
  updateBitCountsOne(t,bits,hb_icons.total[2]);
  updateBitCountsOne(t,bits,hb_icons.gid[2]);
  updateBitCountsOne(t,bits,hb_icons.identical[2]);
}

function mapCountsToDisplay(t) {
  HBCC_count_no.innerHTML     = t[hb_icons.count[2]] || '';
  HBCC_clusters_no.innerHTML  = t[hb_icons.cluster[2]] || '';
  HBCC_advance_no.innerHTML   = t[hb_icons.advance[2]] || '';
  HBCC_offset_no.innerHTML    = t[hb_icons.offset[2]] || '';
  HBCC_total_no.innerHTML     = t[hb_icons.total[2]] || '';
  HBCC_gid_no.innerHTML       = t[hb_icons.gid[2]] || '';
  HBCC_identical_no.innerHTML = t[hb_icons.identical[2]] || '';
}

async function CheckSimilar() {
  const total = wordList.length;
  let i = 0;
  var bits = 0;
  var bit_counts = [];

  if (HBCC_count.checked)     bits |= hb_icons.count[2];
  if (HBCC_clusters.checked)  bits |= hb_icons.cluster[2];
  if (HBCC_advance.checked)   bits |= hb_icons.advance[2];
  if (HBCC_offset.checked)    bits |= hb_icons.offset[2];
  if (HBCC_total.checked)     bits |= hb_icons.total[2];
  if (HBCC_gid.checked)       bits |= hb_icons.gid[2];
  if (HBCC_identical.checked) bits |= hb_icons.identical[2];


  if (isLongRunning()) return; // Something in progress already

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }

  startLongRunning();
  const checkGIDs    = HBGIDs.checked;

  updateHarfBuzzScriptLanguage();

  var checkCount = 0;
  startTheLoop();
  updateStatusMessage(i, checkCount, total);

  let et = new ElapsedTimer();

  for (let i=0; i<total; i++) {
    const phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    wordList[i].updateGids(hbf1);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2, tolCompare);
    updateBitCounts(bit_counts, diff);
    if ((diff & bits) != 0) {
      wordList[i].setChecked(true);
      checkCount++;
    }
    wordList[i].setDiff(diff);  // Update the difference field

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  mapCountsToDisplay(bit_counts);
  doneLongRunning();
}

function updateHBCGlive() {
  updateListByIndex(start_index);
}

async function CheckDifferentGlyphs(onCompletion) {
  let i = 0;
  const total = wordList.length;
  if (isLongRunning()) return;

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a long, LONG time. Continue?')) return;
  }
  startLongRunning();
  let et = new ElapsedTimer();

  updateHarfBuzzScriptLanguage();

  const tolerance = parseFloat(HBCGtolerance.value);

  let checkCount = 0;
  startTheLoop();
  updateStatusMessage(i, checkCount, total);

  for (let i=0; i<total; i++) {
    let diffs = wordList[i].getDifferenceAreaCalc(hbf1, hbf2);
    if (diffs && !onCompletion) {
      if (diffs >= tolerance) {
        wordList[i].setChecked(true);
        checkCount++;
      }      
    }

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      await scheduler.yield();
    }
    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  if (onCompletion) {
    onCompletion();
  }
  doneLongRunning();
}

function CheckNotes(e) {
  elementHidePopover(e);
  var i = 0;
  var count = 0;
  while (i < wordList.length) {
    var note = wordList[i].getNote();
    if (note && (note.length > 0)) {
      wordList[i].setChecked(true);
      count++;
    }
    i++;
  }
  if (count > 0)
    checkListHasChanged();
  updateListByIndex(1);
  updateCheckListCount();
  window.scroll(0,0);
  updateStatusMessage(-1);
  window.alert('Checked '+count+' words');
}

function updateHarfBuzzScriptLanguage() {
  const script = inputScript.value;
  const language = inputLanguage.value;
  hbf1.setScriptLang(script, language);
  hbf2.setScriptLang(script, language);
}

async function UpdateDifferences() {
  let i = 0;
  const total = wordList.length;

  if (isLongRunning()) return;
  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }
  startLongRunning();

  const checkGIDs = HBGIDs.checked;

  updateHarfBuzzScriptLanguage();

  let checkCount = 0;
  startTheLoop();
  updateStatusMessage(i, checkCount, total);

  let et = new ElapsedTimer();

  for (let i=0; i<total; i++) {
    const phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    wordList[i].updateGids(hbf1);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2, tolCompare);
    const theSame = ((diff == 1) && checkGIDs) || (diff == 0) || (diff == 64);
    if (!theSame) {
      wordList[i].setChecked(!wordList[i].getChecked());
      checkCount++;
    }

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      await scheduler.yield();      
    }

    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  doneLongRunning();
}

async function RemoveUnchecked(e) {
  elementHidePopover(e);
  if (isLongRunning()) return;
  if (!window.confirm('Delete all unchecked words?\r\nCannot be undone!!!')) return;
  var i = 0;
  var counter = 0;
  var deletedCount = 0;
  var newWordList = [];
  const size = wordList.length;

  startLongRunning();
  let et = new ElapsedTimer();

  for (let i=0; i<size; i++) {
    counter++;
    const wle = wordList[i];
    if (wle.getChecked()) {
      newWordList.push(wle);
    } else {
      deletedCount++;      
    }
    if (et.elapsed()) {
      updateStatusMessage(i, deletedCount, size);
      await scheduler.yield();
    }
    if (AbortLongRunning) {
      break;
    }
  }

  wordList = newWordList; // Assign the new updated list
  if (typeof wordlist_filename === 'string') {
    if (!wordlist_filename.endsWith('(edited)')) wordlist_filename = wordlist_filename + ' (edited)';
  }
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
  window.alert('Deleted '+deletedCount);
  doneLongRunning();
}

function DeleteDuplicates(e) {
  elementHidePopover(e);
  if (!window.confirm('Delete duplicate words?\r\nCannot be undone!!!')) return;
  const size = wordList.length;
  var res = [];
  var count = 0;
  var cache = {};
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    const wei = findWordInList(res, we.getWord(), cache);
    if (wei >= 0) {
      // already there. Check the notes and checkmark
      res[wei].setChecked(res[wei].getChecked() || we.getChecked());
      const note = we.getNote();
      if (note !== '') {
        if (res[wei].getNote() === '')
          res[wei].setNote(note);
        else
          res[wei].setNote(res[wei].getNote() + '/' + we.getNote());
      }
      count++;
    } else {
      addToList(res, we, cache);
    }
  }
  wordList = res;
  if (count > 0) checkListHasChanged();
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
  window.alert('Duplicates '+count);
}


function _updateAfterSort() {
  checkListHasChanged();
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
}


function compareChecked(a,b) {
  if (a.getChecked()) {
    if (b.getChecked())
      return 0;
    return -1;
  }
  if (b.getChecked())
    return 1;
  return 0;
}

// Create the 'checked' first option
function createCompareFunction(foo) {
  if (!cbCheckedFirst.checked) return foo;
  return function(a,b) {
    const r = compareChecked(a,b);
    if (r != 0) return r;
    return foo(a,b);
  }
}

function SortWordList(e, sortByNote/*, byChecked*/) {
  elementHidePopover(e);
  if (!window.confirm('Sort word list?\r\nCannot be undone!!!')) return;
  var compareWord = function(a,b) {
    const aw = a.getWord();
    const bw = b.getWord();
    if (aw < bw) return -1;
    if (aw > bw) return 1;
    return 0;
  }
  var compareNote = function(a,b) {
    const aw = a.getNote();
    const bw = b.getNote();
    if (aw < bw) {
      if (aw === '') return 1;
      return -1;
    }
    if (aw > bw) {
      if (bw === '') return -1;
      return 1;
    }
    return compareWord(a, b);
  }
  var compareCheck = function(a,b) {
    if (a.getChecked()) {
      if (b.getChecked())
        return compareWord(a,b);
      return -1;
    }
    if (b.getChecked()) {
      return 1;
    }
    return compareWord(a,b);
  }
  if (sortByNote)
    wordList.sort(createCompareFunction(compareNote));
  else
    wordList.sort(createCompareFunction(compareWord));
  _updateAfterSort();
}

const iconsOrder = [
  /*'GG'     : */ '\u{1f7e5}', // üü• - glyphs that collide (serious)
  /*'cb'     : */ '\u{1f7e7}', // üüß - collision near base-base
  /*'cx'     : */ '\u{1f7ea}', // üü™ - collision near base-mark
  /*'cm'     : */ '\u{1f7e6}', // üü¶ - collision near mark-mark
  /*'glue'   : */ '\u{1f7e2}', // üü¢ - mark glyph that glues together two far islands
  /*'island' : */ '\u{1F7E1}', // üü° - base glyph island marker
];

function hasAnyOf(chr, srch) {
  return srch.indexOf(chr);
}

// Find index in txt that contains any character of srch
function findContainsAny(txt, srch) {
  //if (txt && txt.length)
  {
    for (let ii=0; ii<srch.length; ii++) {
      const i = txt.indexOf(srch[ii]);
      if (i >= 0) {
        return {
          index:i,
          search: ii,
          found: true,
        }
      }
    }
  }
  return {
    index: 0,
    search: 1e6, // we didn't find any icons
  };
}

function compareIgnoring(txta, idxa, txtb, idxb, srch) {
  while (idxa < txta.length) {
    if (idxb >= txtb.length) return 1;

    const ca = txta.codePointAt(idxa);
    if (srch.indexOf(String.fromCodePoint(ca))>= 0) {
      idxa += (ca>0xffff)?2:1;
      continue;
    }
    
    const cb = txtb.codePointAt(idxb);
    if (srch.indexOf(String.fromCodePoint(cb))>= 0) {
      idxb += (cb>0xffff)?2:1;
      continue;
    }

    if (ca > cb) return 1;
    if (ca < cb) return -1;
    idxa += (ca>0xffff)?2:1;
    idxb += (cb>0xffff)?2:1;
  }
  if (idxb < txtb.length) return -1;
  return 0;
}

function SortWordListByInfo(e) {
  elementHidePopover(e);
  if (!window.confirm('Sort word list?\r\nCannot be undone!!!')) return;

  /*
  const compareWord = function(a,b) {
    const aw = a.getWord();
    const bw = b.getWord();
    if (aw < bw) return -1;
    if (aw > bw) return 1;
    return 0;
  }

  const compareInfo = function(a,b) {
    const ai = a.getInfo();
    const bi = b.getInfo();

    // Find the icons by order of Font Force Field Info output.
    const air = findContainsAny(ai, iconsOrder);
    const bir = findContainsAny(bi, iconsOrder);

    // Compare the first icon initially
    if (air.search > bir.search) return 1;
    if (air.search < bir.search) return -1;
    // Compare from air.index and bir.index onwards
    // skip past any icons to compare the glyphs only
    const r = compareIgnoring(ai, air.index, bi, bir.index, iconsOrder);
    if (r != 0) return r;

    if (ai > bi) return 1;
    if (ai < bi) return -1;
    return compareWord(a,b);
  }
  wordList.sort(createCompareFunction(compareInfo));
  */
  const compareInfo = function(a,b) {
    return a.compareInfoWorst(b);
  }
  wordList.sort(createCompareFunction(compareInfo));
  _updateAfterSort();
}

function SortWordListArea(e) {
  elementHidePopover(e);
  if (!window.confirm('Sort word list?\r\nCannot be undone!!!')) return;
  HBCGlive.checked = true;
  CheckDifferentGlyphs( () => {
    var compare = function(a,b) {
      let da = a.getDifferenceArea();
      let db = b.getDifferenceArea();
      if (da > db)
        return -1;
      if (da < db)
        return 1;
      const aw = a.getWord();
      const bw = b.getWord();
      if (aw < bw) return -1;
      if (aw > bw) return 1;
      return 0;
    }
    wordList.sort(compare);
    _updateAfterSort();    
  });
}

function DeleteAll(e) {
  elementHidePopover(e);
  if (!window.confirm('Delete all words?\r\nCannot be undone!!!')) return;
  wordList = [];
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
}

// See: https://github.com/MattMatic/unique-words
function findUniqueWords(input, options) {
  let lang = options.language;
  if (lang === '') lang = 'en';
  let segmenter = new Intl.Segmenter(lang, {granularity: 'word'});
  let segments = segmenter.segment(input);
  let words = {};
  for (let {segment, index, isWordLike} of segments) {
    if (isWordLike) {
      let hasNumbers =  /\d/.test(segment);
      if (!hasNumbers || options.numbers) {
        if (options.normalize) segment = segment.normalize();
        words[segment] = true;  // Assimilate a list
      }
    }
  }
  var res = [];
  for (const word in words) {
    res.push(word);
  }
  if (options.sort) {
    res.sort();
  }
  return res;
}

function assimilateText(input) {
  var options = {
    language: HTMLLang.value,
    sort: true,
    numbers: false,
  }
  var words = findUniqueWords(input, options);

  const wordsLength = words.length;
  const inputShort = input.substring(1, 40);
  const confirmMessage = 'Paste '+wordsLength+' unique words from "'+inputShort+'..." ?';
  if (!window.confirm(confirmMessage)) {
    return;
  }
  var count = 0;
  var cache = {};
  words.forEach( (w) =>  {
    var mi = findWordInList(wordList, w, cache);
    if (mi >= 0) {
      // Found the word
    } else {
      const newEntry = new wordEntryClass(w);
      count++;
      newEntry.setChecked(true);
      addToList(wordList, newEntry, cache);
    }
  });
  checkListHasChanged();
  updateCheckListCount();
  updateListByField();
  UpdateWordCount();  
  window.alert(count+' new words were added');
}

async function pasteUniqueWords() {
  // Access clipboard and use Intl.segmenter to pull out words
  let input = '';
  try {
    const clipboardContents = await navigator.clipboard.read();
    for (const item of clipboardContents) {
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const blobText = await blob.text();
        assimilateText(blobText);
      }
    }
  } catch (error) {
    console.log(error.message);
  }
  if (!wordlist_filename) wordlist_filename = '(clipboard)';
}

var hbfcw = null;
var ffftw = null;
var api = {};

function prepareApi() {
  api = {};
  api.transfer = {}
  api.transfer.script = inputScript.value;
  api.transfer.language = inputLanguage.value;
  api.transfer.direction = null;
  api.transfer.fontBlob1 = hbf1.fontBlob;
  api.transfer.fontBlob2 = hbf2.fontBlob;
  api.transfer.wordList = [];
  api.transfer.checkList = [];
  var i = 0;
  const size = wordList.length;
  while (i < size) {
    const word = wordList[i].word;
    if (wordList[i].getChecked()) {
      api.transfer.checkList.push(word);
    }
    api.transfer.wordList.push(word);
    i++;
  }
}

function openFontCompareTool(e) {
  elementHidePopover(e);
  prepareApi();
  if (!hbfcw || hbfcw.closed) {
    var hbfc_url;
    if (window.location.hostname === 'localhost')
      hbfc_url = '../hbfontcompare/index.html';
    else
      hbfc_url = 'https://mattmatic.github.io/hbfontcompare/index.html';
    hbfcw = window.open(hbfc_url, 'mattmatic.hbfontcompare')
  } else {
    hbfcw.updateTransfer(api.transfer);
    hbfcw.focus();
  }
}

function openFontForceFieldTool(e) {
  elementHidePopover(e);
  prepareApi();
  if (!ffftw || ffftw.closed) {
    var ffft_url;
    if (window.location.hostname === 'localhost')
      ffft_url = '../font-force-field/index.html';
    else
      ffft_url = 'https://mattmatic.github.io/font-force-field/index.html';
    ffftw = window.open(ffft_url, 'mattmatic.font-force-field')
  } else {
    ffftw.updateTransfer(api.transfer);
    ffftw.focus();
  }
}

function acquireFontAndLists(w) {
  if (!w?.api?.transfer) return;
  const xfer = w.api.transfer;  // Use this as a conduit for values to be passed in here
  inputScript.value = xfer.script;
  inputLanguage.value   = xfer.language;
  wordlist_filename = xfer.wordListFileName;
  
  // xfer.wordList
  wordList = [];
  const size = xfer.wordList.length;
  for(let i = 0; i<size; i++) {
    const xwe = xfer.wordList[i];
    var wordEntry = new wordEntryClass(xwe.word);
    wordEntry.checked = xwe.checked;
    wordEntry.note = xwe.note;
    wordEntry.info = xwe.info;
    wordList.push(wordEntry);    
  }
  applyFontX(null, 'Test_Font_1', fontOneInfo, hbf1, xfer.fontBlob);
  // Not font 2...
  updateLanguage();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(start_index);
  window.scroll(0,0);
  disableSaveButton();
}

function updateTransfer(xfer) {
  acquireFontAndLists(window.opener);
}


function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function saveTextToFile(txt, filename) {
  var bb = new Blob([txt], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = filename;
  a.href = window.URL.createObjectURL(bb);
  a.target='_blank';
  a.click();
}

function DownloadCheckList(e) {
  elementHidePopover(e);
  var txt = '';
  if (hbf1.fontNames) {
    txt += `\t#\t"FONT1","${hbf1.fontNames.fullName}","${hbf1.fontNames.version}","HarfBuzz ${hbf1.hbVersion}"\r\n`;
  }
  if (hbf2.fontNames) {
    txt += `\t#\t"FONT2","${hbf2.fontNames.fullName}","${hbf2.fontNames.version}","HarfBuzz ${hbf2.hbVersion}"\r\n`;
  }
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) {
      txt = txt + wordList[i].getLine()+'\n';
    }
    i++;
  }
  saveTextToFile(txt, 'CheckList.'+DateTimeForFilename()+'.txt');
}


// Ref: https://gist.github.com/Explosion-Scratch/357c2eebd8254f8ea5548b0e6ac7a61b
function compressStringToArrayBuffer(txt, encoding = 'gzip') {
  const byteArray = new TextEncoder().encode(txt);
  const cs = new CompressionStream(encoding);
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  const buff = new Response(cs.readable).arrayBuffer();
  return buff;
}

function decompressArrayBufferToString(byteArray, encoding='gzip') {
  const cs = new DecompressionStream(encoding);
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  return new Response(cs.readable).arrayBuffer().then(function (arrayBuffer) {
    return new TextDecoder().decode(arrayBuffer);
  });
}

function encodeArrayBufferToBase64(arrayBuffer) {
  const base64String = btoa(
    new Uint8Array(arrayBuffer)
      .reduce((data, byte) => data + String.fromCharCode(byte), '')
  );
  return base64String;
}

function decodeBase64ToArrayBuffer(base64String) {
  return Uint8Array.from(atob(base64String), c=>c.charCodeAt(0));
}

async function saveToLocalStorage() {
  const ls = window.localStorage;
  try {
    ls.setItem('wordListFilename', wordlist_filename || '');
    ls.setItem('html_language', HTMLLang.value);
    ls.setItem('harfbuzz_script', inputScript.value);
    ls.setItem('harfbuzz_language', inputLanguage.value);
    ls.setItem('start_index', start_index);
    if (hbf1.fontNames) {
      ls.setItem('font1.name',    hbf1.fontNames.fullName);
      ls.setItem('font1.version', hbf1.fontNames.version);
    }
    if (hbf2.fontNames) {
      ls.setItem('font2.name',    hbf2.fontNames.fullName);
      ls.setItem('font2.version', hbf2.fontNames.version);
    }
    const wlSave = [];
    wordList.forEach(we => {
      wlSave.push(
        {
          word:     we.word,
          note:     we.note,
          checked:  we.checked,
          info:     we.info,
        }
        );
    });
    const json = JSON.stringify(wordList);
    const buff = await compressStringToArrayBuffer(json);
    const b64 = encodeArrayBufferToBase64(buff);
    ls.setItem('wordList', b64);
    //---- localStorage is VERY limited. Cannot save the font :-(
    //ls.setItem('fontBlob1', JSON.stringify(hbf1.fontBlob));
    //ls.setItem('fontBlob2', JSON.stringify(hbf2.fontBlob));
  } catch(error) {
    window.alert(error);
  }
  resetCheckListChanged(); // Because we've save it
}

function clearLocalStorage() {
  if (!window.confirm('Clear all words, check lists, notes, and localStorage?\r\nCANNOT be undone!!!')) return;
  window.localStorage.clear();
  loadFromLocalStorage();
  resetCheckListChanged(); // Because we've save it
  wordList = [];
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  mapCountsToDisplay([]);
}

var ls_wordlist = [];

function setLastFontDetails(root, id) {
  const ls = window.localStorage;
  var name     = ls.getItem('font'+root+'.name');
  var version  = ls.getItem('font'+root+'.version');
  id.innerHTML = 'Drag-and-Drop Font '+root;
  if (!name) return;
  if (!version) return;
  id.innerHTML = '<font color="red"><em>Drag-and-drop font:</em></br>'
      + name + '</b></br>'
      + '<font size="-1">'+version+'</font></font>';
}

function cbHarfBuzzFixChange(event) {
  const fix = cbHarfBuzzFix.checked;
  hbf1.hbFix = fix;
  hbf1.gc.hbFix = fix;
  hbf2.hbFix = fix;
  hbf2.gc.hbFix = fix;
  updateListByField();
}


async function loadFromLocalStorage() {
  if (window?.opener?.api?.transfer) return; // NOTE: hack as I have some nasty async issue that calls this AFTER the acquireFromTransfer has been executed
  const ls = window.localStorage;
  var _wl = ls.getItem('wordList');
  var buff;
  try {
    buff = decodeBase64ToArrayBuffer(_wl);
    if (buff) {
      // Wordlist is compressed...
      _wl = await decompressArrayBufferToString(buff);
    }
  } catch(e) {
    buff = null;
  }
  wordlist_filename = ls.getItem('wordListFilename');
  if (_wl) {
    ls_wordlist = JSON.parse(_wl);
    wordList = [];
    var i = 0;
    while (i < ls_wordlist.length) {
      const wle = ls_wordlist[i];
      const wordEntry = new wordEntryClass(wle.word);
      wordEntry.checked = wle.checked;
      wordEntry.note = wle.note;
      wordEntry.info = wle.info;
      wordList.push(wordEntry);
      i++;
    }
    start_index = ls.getItem('start_index');
    if (!start_index) start_index = 1;
    updateCheckListCount();
    UpdateWordCount();
    updateListByIndex(start_index);
    window.scroll(0,0);
    disableSaveButton();
  }
  setLastFontDetails('1', fontOneInfo);
  setLastFontDetails('2', fontTwoInfo);
  showFontTwo(false);
  //---- localStorage is very limited - cannot store the fontBlobs, alas
  //var _fontBlob1 = ls.getItem('fontBlob1');
  //if (_fontBlob1) applyFontX(null, 'Test_Font_1', fontOneInfo, hbf1, _fontBlob1);
  //var _fontBlob2 = ls.getItem('fontBlob2');
  //if (_fontBlob2) applyFontX(null, 'Test_Font_2', fontTwoInfo, hbf2, _fontBlob2);
}

document.getElementById('start').addEventListener('keydown', (evt) => {
  if (evt.keyCode == 13) {
    gotoOrFind();
  }
});

//---------------------------Fill in the text as separate lines------------------
ClearCheckList();
updateListByIndex(1)
//===============================================================================

function UpdateWordCount() {
  var wlc = document.getElementById('wordcount');
  var txt = 'Count:'+wordList.length;
  if (typeof wordlist_filename === 'string') {
    txt = txt + ' '+wordlist_filename;
  }
  wlc.innerHTML = txt;
}

//------------------------------
// Drag and drop functions
//------------------------------
function handleWordsDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Continue?')) return;
  }

  wordlist_filename = '"'+fileName+'"';
  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    wordList = buildListFromFileContents(txt);
    ClearCheckList();
    updateListByIndex(1);
    UpdateWordCount();
    enableSaveButton();
  }
  reader.readAsText(file);
}

function handleCheckDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    var checkWordList = buildListFromFileContents(txt);
    var i = 0;
    var cache = {};
    while (i < checkWordList.length) {
      const cwle = checkWordList[i];
      const word = cwle.getWord();
      var mi = findWordInList(wordList, word, cache);
      var note = cwle.getNote();
      if (mi >= 0) {
        wordList[mi].setChecked(true);
        if (note && (note.length > 0)) {
          wordList[mi].setNote(note);
        }
      } else {
        const newEntry = new wordEntryClass(word);
        newEntry.setNote(note);
        newEntry.setChecked(true);
        addToList(wordList, newEntry, cache);
      }
      i++;
    }
    checkListHasChanged();
    updateCheckListCount();
    updateListByField();
    UpdateWordCount();
  }
  reader.readAsText(file);
}

function applyFontX(file, fontname, id, hbo, data) {
  hbo.setFontBlob(new Uint8Array(data));
  const fontFace = new FontFace(fontname, data);
  const fontInfo = FontName.parse(data);
  const fontName = fontInfo[0];
  hbo.fontNames = fontName;
  id.innerHTML = fontName.fullName + '</b></br><font size="-1">' + fontName.version + "</font>";
  fontFace.load().then(
    () => {
      deleteFontByName(fontname);
      document.fonts.add(fontFace);
      //--//if (file) console.log('loaded '+file.name);
      changeFontAscentDescent(fontname, '200%', '200%');
      fontsHaveChanged();
      updateListByField();
      updateLanguage();
      if (hbo === hbf1) {
        //NOTE: if debug is not available, we can still use gid # and gpos table #
        //regExpGlyph.disabled = !hbf1.getGlyphName(0);
        //regExpGpos.disabled = !hbf1.debugInfo;
        regExpGlyph.disabled = false;
        regExpGpos.disabled = false;
        gidGposAnalytics.hidden = false;
      }
    },
    (err) => {
      console.error(err);
    }
    );
}

function handleFontXDrop(file, fontname, id, hbo) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.ttf') && !fileName.endsWith('.otf')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    applyFontX(file, fontname, id, hbo, reader.result);
    saveToLocalStorage();
    updateTolerance();
  }
  reader.readAsArrayBuffer(file);
}

function handleFontOneDrop(file) {
  handleFontXDrop(file, 'Test_Font_1', fontOneInfo, hbf1);
}

function handleFontTwoDrop(file) {
  handleFontXDrop(file, 'Test_Font_2', fontTwoInfo, hbf2);
  showFontTwo(true);
}

patchDragDrop(WordsDragDrop, handleWordsDrop);
patchDragDrop(CheckDragDrop, handleCheckDrop);
patchDragDrop(fontOneInfoCell, handleFontOneDrop);
patchDragDrop(fontTwoInfoCell, handleFontTwoDrop);

showFontTwo(false);


</script>

</br>Tool Version: 2026-01-18 k</p>
</body>
</html>
