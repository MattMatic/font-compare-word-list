<html>

<head>
<meta charset="utf-8">
<!--
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gulzar|Noto+Nastaliq+Urdu">
-->
<style>
  body {
    font-family: "Calibri";
    background-color: #aacccc;
  }
.test_1 {
  font-family: "Test_Font_1";
  font-kerning: normal;
  font-size: 200%;
  color: #000080;
  text-align: center;
}

.test_2 {
  font-family: "Test_Font_2";
  font-kerning: normal;
  font-size: 200%;
  color: #ee6600;
  text-align: center;
}

.HBC {
  font-family: "Consolas";
  text-align: center;
}

.overlap {
  text-align: center;
  line-height: 0px;
}
.note {
  width: 60%;
}

input[type="text"] {
  font-size: 100%;
}
table, th, td {
  border: 2px solid #448888;
  border-collapse: collapse;
  padding: 8px;
}
td {
  align: 'left';
}
.hbtype table, .hbtype th, .hbtype td {
  border: 0px;
  padding: 4px;
}
.wordlist, input[type="file"] {
  background-color: #8ebf42;
}
.dropbtn {
  border-radius: 4px;
  background-color: rgba(96,192,128,0.5);
  color: black;
  padding: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
  font-size: 100%
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  align: left;
  border-radius: 2px 8px 12px 12px;
  display: none;
  position: absolute;
  background-color: #eff;
  min-width: 200px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}
.dropdown-content a{
  color: black;
  padding: 8px 12px;
  text-decoration: none;
  display: block;
}
th .dropdown-content{
  text-align: left;
  font-weight: bold;
  font-size: 100%;
}
.dropdown-content a:hover {background-color: #cee;}
.dropdown:hover .dropdown-content {
  display: block;
}
.dropdown:hover .dropbtn {
  background-color: #3e8e41;
  color: white;
}
.vectors {
  position: fixed;
  display: none;
  background-color: #eff;
  min-width: 600px;
  z-index: 0;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #ccc;
  color: #006080;
}
.tooltip .tooltiptext {
  visibility: hidden;
  position: absolute;
  width: 340px;
  background-color: #555;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip-bottom {
  top: 135%;
  left: 50%;
  margin-left: -60px;
}
.tooltip-bottom::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  margin-width: 5px;
  border-style: solid;
  border-color: transparent transparent #555 transparent;
}
</style>

<script type="text/javascript" src="./js/hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="./js/hbjs.js"></script> <!-- Wrapper, can be used without -->
<script type="text/javascript" src="./js/fontname.min.js"></script>
<script type="text/javascript" src="./js/flatbezier.js"></script>
<script type="text/javascript" src="./js/otinfo.min.js"></script>
<script type='module' src="./js/glyphcompare.mjs" async></script>
<script type='module' async>
import {CPaths64, GlyphCompareClass} from './js/glyphcompare.mjs';

import * as opentype from './js/opentype.min.mjs';
import Layout from './js/opentype.layout.gdef.mjs';
window.opentype = opentype;
window.Layout = Layout;

window.CPaths64 = CPaths64;
window.GlyphCompareClass = GlyphCompareClass;
function onResourcesLoaded() {
  window.loadFromLocalStorage();
  if ((window.opener !== null) && (window.opener.openFontCompareWordListTool)) {
    window.acquireFontAndLists(window.opener);
  }
  window.toggleHBIcons();
  /*
  import('./js/glyphcompare.mjs').then((module) => {
    GlyphCompare = module;
  });
  */
}

let harfBuzzModule; // not really needed with the hbjs wrapper
createHarfBuzz().then(hbmodule=>{
  harfBuzzModule = hbmodule;
  window.hb = hbjs(hbmodule);
  window.hbversion.innerHTML = hb.version_string();
  onResourcesLoaded();
});
</script>

<script>
"use strict";


//------------------------------
// Drag and drop utilities
//------------------------------

function chooseFile(func) {
  var filein = document.createElement('input');
  filein.type = 'file';
  filein.onchange = e => {
    var file = e.target.files[0];
    func(file, e);
  }
  filein.click();
  try {
    document.body.removeChild(filein);
  } catch (e) {
    // ignore
  }
}

function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
  ele.addEventListener('mousedown', function(e) {
    if (e.button === 2) {
      chooseFile(foo);
    }
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);
window.addEventListener('beforeunload', function(e) {
  if (!checkListChanged) return undefined;
  var confirmMessage = 'CheckList is not yet saved. If you leave before saving, changes will be lost!';
  (e || window.event).returnValue = confirmMessage;
  return confirmMessage;
});


//------------------------------
// Document/CSS Font Utilities
//------------------------------
function changeFontAscentDescent(name, asc, desc) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        v.ascentOverride  = asc;
        v.descentOverride = desc;
      }
    }
  );
}

function deleteFontByName(name) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        document.fonts.delete(v);
      }
    }
  );
}

//------------------------------
// Build table
//------------------------------
var start_index = 1
var per_block = 100
var line = 1

var update_interval = 131;
var checkListChanged = false;
var wordlist_filename = '';

function disableSaveButton() {
  saveButton.disabled = true;
  saveButton.style = '';
}

function enableSaveButton() {
  saveButton.disabled = false;
  saveButton.style = 'background-color:#f44336; color:white';
}

function checkListHasChanged() {
  checkListChanged = true;
  enableSaveButton();
}

function resetCheckListChanged() {
  checkListChanged = false;
  disableSaveButton();
}

function wordHTML(txt,fnt) {
  //return '<div class="'+fnt+'" align="center"><p>'+txt+'</p></div>'
  return '<div class="'+fnt+'"><p>'+txt+'</p></div>'
}

function MarkUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setChecked(e.checked);
  updateCheckListCount();
  checkListHasChanged();
}

function BuildMarkHtml(n) {
  var txt = '<input type="checkbox" onclick="MarkUpdate(this);" name="mark'+(n+1)+'"';
  if (wordList[n].getChecked()) txt = txt + ' checked';
  txt = txt + '>';
  return txt;
}

function NoteUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setNote(e.value);
  checkListHasChanged();
}

function BuildNoteHtml(n) {
  var txt = '<input type="text" class="note" onchange="NoteUpdate(this);" onkeyup="NoteUpdate(this);" name="note'+(n+1)+'" value="';
  txt = txt + wordList[n].getNote();
  txt = txt + '">';
  return txt;
}

function BuildDifference(n, phrase) {
  if (!HBCGlive.checked) return '';
  let da = wordList[n].getDifferenceArea();
  if (typeof da === 'undefined') da = wordList[n].calcDifferenceArea(hbf1, hbf2);
  if (da === 0) return '';
  return da;
}

const hb_icons = {
  identical: ['&#x2705;' , '✅',  64],     // Green tick
  count    : ['&#x1F7E5;', '🟥', 128],     // Red
  cluster  : ['&#x1F7E8;', '🟨',   2],     // Yellow
  advance  : ['&#x1F7E6;', '🟦',   8],     // Blue
  offset   : ['&#x1F7EA;', '🟪',   4],     // Purple
  gid      : ['&#x2b1c;' , '⬜',   1],     // White
  reg_exp  : new RegExp('[✅🟥🟨🟦🟪⬜]', 'g')
};

function diffFieldToText(diff) {
  var res = '';
  if (diff < 0) return '';
  if ((diff == 0) || (diff === 64)) return hb_icons.identical[0];
  const sep = "";//</br>";
  if (0 != (diff & hb_icons.count[2]))    res = res + hb_icons.count[0]   + sep;
  if (0 != (diff & hb_icons.cluster[2]))  res = res + hb_icons.cluster[0] + sep;
  if (0 != (diff & hb_icons.advance[2]))  res = res + hb_icons.advance[0] + sep;
  if (0 != (diff & hb_icons.offset[2]))   res = res + hb_icons.offset[0]  + sep;
  //if (0 != (diff & hb_icons.gid[2]))   res = res + hb_icons.gid[0]     ;//+ "</br>";
  return res;
}

function diffValueToUnicode(diff) {
  var res = '';
  if (diff < 0) return res;
  if ((diff == 0) || (diff === 64)) return hb_icons.identical[1];
  if (0 != (diff & hb_icons.count[2])) res = res + hb_icons.count[1];
  if (0 != (diff & hb_icons.cluster[2]))   res = res + hb_icons.cluster[1];
  if (0 != (diff & hb_icons.advance[2]))   res = res + hb_icons.advance[1];
  if (0 != (diff & hb_icons.offset[2]))   res = res + hb_icons.offset[1];
  //if (0 != (diff & hb_icons.gid[2]))   res = res + hb_icons.gid[1];
  return res;
}

function diffValueToNote(existingNote, diff) {
  var res = existingNote;
  res = res.replace(hb_icons.reg_exp, '');
  return res + diffValueToUnicode(diff);
}

var tolCompare;

function generateToleranceCompareFunction(tolerance) {
  var fn;
  if (tolerance && (tolerance !== '')) {
    if (tolerance.includes('%')) {
      const tol = parseFloat(tolerance) / 100;
      fn = function(a, b) {
        if ((Math.abs(a-b) / ((a+b)/2)) > tol) {
          return true;
        }
        return false;
      }
    } else {
      const diff = parseFloat(tolerance);
      fn = function(a,b) {
        if (Math.abs(a-b) > diff) return true;
        return false;
      }
    }
  } else {
    fn = function(a,b) {
      if (a !== b)
        return true;
      else
        return false;
    }
  }
  return fn;
}

tolCompare = generateToleranceCompareFunction(null);

function updateTolerance() {
  var tolerance = HBCC_tolerance.value;
  tolCompare = generateToleranceCompareFunction(tolerance);
}

function addEntry(lineNo, theWordEntry, displayValue) {
  //if (txt == '') return;
  var table = document.getElementById('word_list');
  var row = table.insertRow();
  var idx=1;

  var phrase = theWordEntry.getWord();
  hbf1.shape(phrase);
  theWordEntry.updateGids(hbf1);  
  hbf2.shape(phrase);
  var diff = hbf1.compare(hbf2, tolCompare);
  theWordEntry.setDiff(diff);

  row.insertCell(0).innerHTML = '<div align="center">'+(lineNo+1)
      +BuildMarkHtml(lineNo)
      +' '+BuildNoteHtml(lineNo)
      +'</div>';
  row.insertCell(idx++).innerHTML = '<div class="HBC">'
      //diffFieldToText(diff)+
      +theWordEntry.getDiff()
      +'</br>'+BuildDifference(lineNo, phrase)
      +'</div>';
  row.insertCell(idx++).innerHTML = wordHTML(phrase, "test_1");
  var cell = row.insertCell(idx++);
  cell.innerHTML = wordHTML(phrase, "test_2");
  cell.style.display = displayValue;
  cell = row.insertCell(idx++);
  cell.innerHTML =
      //'<p style="line-height: 0px; " align="center">'
      '<p class="overlap" id="overlap'+lineNo+'">'
    + '<span class="test_2" style="color: #ff6600;">' + phrase + '</span><br>'
    + '<span class="test_1">' + phrase + '</span></p>'
  cell.style.display = displayValue;
}

function updateListByIndex(idx) {
  updateHarfBuzzScriptLanguage();

  const displayValue = window.getComputedStyle(fontOverlap).display;
  var table = document.getElementById('word_list')
  var s = table.rows.length;
  while (s > 1) {
    s--;
    table.deleteRow(s);
  }
  var n =  per_block;
  for (var i=(idx-1); i < (idx-1+n); i++) {
    if (wordList[i] === undefined) break;
    addEntry(i, wordList[i], displayValue);
  }
  // Patch in the mouse hover action
  for (let i=(idx-1); i<(idx-1+n); i++) {
    if (wordList[i] === undefined) break;
    let ele = document.getElementById('overlap'+i);
    if (ele) {
      ele.addEventListener(
        "mouseenter",
        (event) => {
          showOverlap(wordList[i].getWord(), i+1, event);
        },
        false,
      );
      ele.addEventListener(
        "mouseleave",
        (event) => {
          hideOverlap(event);
        },
        false,
      );
    }
  }
  const e = document.getElementById('start');
  if (idx != e.value) {
    enableSaveButton();
  }
  e.value = String(idx);
}

function getStart() {
  var txt = document.getElementById('start').value;
  if (isNaN(txt)) return start_index;
  var i = Number(txt);
  if (i < 1) {
    i = 1;
  }
  if (i > wordList.length) {
    i = wordList.length-1;
  }
  return i;
}

function setStart(idx) {
  document.getElementById('start').value = String(idx);
}

function gotoOrFind() {
  var txt = document.getElementById('start').value;
  if (isNaN(txt)) {
    // Let's try and locate...
    var search_index = start_index;
    const list_length = wordList.length;
    while (search_index < list_length) {
      if (wordList[search_index].getWord().search(txt) >= 0) {
        start_index = search_index + 1;
        setStart(start_index);
        updateListByIndex(start_index);
        document.getElementById('start').value = txt; // Keep text in the search
        break;
      }
      search_index++;
    }
    // Not found!
    //document.getElementById('start').value = start_index;
  } else {
    // This is a number... let's jump to the location
    updateListByField();
  }
}

function updateListByField() {
  start_index = getStart();
  if (start_index <= 1) start_index = 1;
  setStart(start_index);
  updateListByIndex(start_index);
}

function updateListNext() {
  start_index = getStart() + per_block;
  if (start_index > wordList.length) start_index = wordList.length - 2;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}

function updateListPrev() {
  start_index = getStart() - per_block;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}

function updateListFirst() {
  start_index = 1;
  updateListByIndex(start_index);
}

function updateListLast() {
  start_index = wordList.length - per_block + 1;
  updateListByIndex(start_index);
}

function updateCssStyle(name, styleid, value) {
  const rules = document.styleSheets[0].cssRules;
  for (var i=0, rl=rules.length; i<rl; i++) {
    if (rules[i].selectorText == name) {
      rules[i].style[styleid] = value;
      break;
    }
  }
}

function updateAlign() {
  const alignRadios = document.getElementsByName('alignment');
  var text_align = 'center';
  for (var i=0, rl=alignRadios.length; i<rl; i++) {
    if (alignRadios[i].checked) {
      text_align = alignRadios[i].value;
      break;
    }
  }
  updateCssStyle('.test_1', 'text-align', text_align);
  updateCssStyle('.test_2', 'text-align', text_align);
  updateCssStyle('.overlap', 'text-align', text_align);
}

function cssRulesIterate(func) {
  const ruleList = document.styleSheets[0].cssRules;
  for (const rule of ruleList) {
    func(rule);
  }
}

function setFontSize(size) {
  cssRulesIterate(rule => {
    if (rule.selectorText.startsWith('.test_')) {
      rule.style.fontSize = size;
    }
  });
}

</script>
</head>

<body>

<h1>
  Font Compare Word List Tool
</h1>

<table width="100%" border=1>
  <tr>
    <td width="22%">
      Actions
    </td>
    <td>
      <button id='saveButton' onclick='saveToLocalStorage();' disabled=true title='Save state in localStorage'>Save</button>
      &bull;
      <button onclick='clearLocalStorage();' title='Reset and Clear'>Reset</button>

      <div class='dropdown'>
        <!--<button class='dropbtn'></button>-->
        <div class='dropdown-content' id='ddProgress'>
          <table border=0 width='100%'><tr><th>Progress:</th><td><div id='statusUpdate'>-</div> <button onclick='doAbortLongRunning();' id='AbortButton' hidden>Abort!</button></td></tr></table>
        </div>
      </div>
    </td>
  </tr>
</table>

<table border=1 cellspacing="8px" width="100%">
  <tr>
    <td width='22%'>
      <label for='start'>Start:</label><input type='text' id='start' placeholder='Start' value='1' width='8'/>
      <button onclick='gotoOrFind();' title='Jump to "Start" as a line number, or &#13;&#10; search for the text in "Start"'>Go</button>
    </td>
    <td width='26%' align='center'>
      <button onclick='updateListFirst();' accesskey='1'>First (Alt-1)</button>
      <button onclick='updateListPrev();' accesskey='2'>Prev (Alt-2)</button>
      <button onclick='updateListNext();' accesskey='3'>Next (Alt-3)</button>
      <button onclick='updateListLast();' accesskey='4'>Last (Alt-4)</button>
    </td>
    <td width="26%" id='WordsDragDrop' align='center'>
      <span id='wordcount'><b><span style='background-color:cyan;'>Drag-and-drop Word List (.txt) file here</b></span></span>
    </td>
    <td align='center'>
      <span>
        <input type='radio' name='alignment' value='left' onclick="updateAlign();">
          <label for='left'>Left</label>
        <input type='radio' name='alignment' value='center' onclick="updateAlign();" checked>
          <label for='center'>Center</label>
        <input type='radio' name='alignment' value='right' onclick="updateAlign();">
          <label for='right'>Right</label>
      </span>
    </td>
  </tr>
</table>
</br>

<!-- Menus Start -->
  <div class='dropdown'>
    <button class='dropbtn'>🔤Word List</button>
    <div class='dropdown-content' id='ddWordList'>
    <a href='#' onclick='DownloadCheckList();' title='Save check list to file'>⏬Download</a></br>
    <a href='#' onclick='pasteUniqueWords();' title='Paste Unique words - new words are checked'>⭐Paste Unique</a></br>
    </div>
  </div>
  <div class='dropdown'>
    <button class='dropbtn'>📊Sort</button>
    <div class='dropdown-content' id='ddWordList'>
    <a href='#' onclick='SortWordList(false);' title='Sort by Word'>🔤Word</a></br>
    <a href='#' onclick='SortWordList(false, true);'  title='Sort by Check then Word'>✅Check + Word</a></br>
    <a href='#' onclick='SortWordList(true);'  title='Sort by Note then Word'>📓Note + Word</a></br>
    <a href='#' onclick='SortWordListArea();'  title='Sort by Difference Area'>📐Area + Word</a></br>
    </div>
  </div>
  <div class='dropdown'>
    <button class='dropbtn'>✅Check List</button>
    <div class='dropdown-content'>
    <a href='#' onclick='ClearCheckListUser();' title='Remove check from all words'>⬜Clear All</a></br>
    <a href='#' onclick='CheckAllList();' title='Check all words'>✅Set All</a></br>
    <a href='#' onclick='InvertCheckList();' title='Toggle check for all words'>🔵Invert</a></br>
    <a href='#' onclick='CheckNotes();' title='Check all words that have some text in the note field'>📓Check Notes</a></br>

    <a href='#' onclick='openFontCompareTool();' title='Send checked words to HarfBuzz Font Compare Tool'>➜ Font Compare</a></br>
    <a href='#' onclick='openFontForceFieldTool();' title='Send checked words to Font Force Field Tool'>➜ Force Field</a></br>

    <span id='gidGposAnalytics' hidden><a href='#' onclick='processChecklistGpos();' title='Process GPOS/GID data'>📈 Glyph/GPOS analytics</a></span></br>
    </div>
  </div>

  <div class='dropdown'>
    <button class='dropbtn'>🔍Search</button>
    <div class='dropdown-content'>
      <table border=0 width='100%'>
        <tr><th>Notes:</th><td><input type='text' name='regExpNotes' id='regExpNotes'/></td></tr>
        <tr><th>Word:</th><td><input type='text' name='regExpWord' id='regExpWord'/></td></tr>
        <tr><th>Glyph(s):</th><td><input type='text' name='regExpGlyph' id='regExpGlyph' title='Integer or string. Separate multiple with comma' disabled/>
        </td></tr>
        <tr><th>GPOS:</th><td><input type='text' name='regExpGpos' id='regExpGpos' title='Integer or string. Separate multiple with comma' disabled/>
        </td></tr>
        <tr><th></th><td>Regular Expression Hint: ^=start, $=end, \=escape</td>
        <tr><th>Check:</th><td>
          <input type='radio' name='regExpOp' value='check' checked><label for='check'>Check</label></br>
          <input type='radio' name='regExpOp' value='uncheck'><label for='uncheck'>Uncheck</label></br>
          <input type='radio' name='regExpOp' value='invert'><label for='invert'>Invert</label>          
        </td></tr>
        <tr><th></th><td>
          <button onclick='CheckmarkRegExp();' title='Run regular expression and adjust check'>Search</button>
        </td></tr>
      </table>
    </div>
  </div>

  <div class='dropdown'>
    <button class='dropbtn'>&#x1F30D;HarfBuzz</button>
    <div class='dropdown-content'>
      <table border=0 width='100%'>
        <tr><th>HTML Lang:</th><td><input type='text' id='HTMLLang' oninput='updateLanguage();' title='Web page language ID'/></td></tr>
        <tr><th>Script:</th><td>
          <span class='tooltip'>
            <input type='text' id='inputScript' oninput='updateLanguage();'/>
            <span class='tooltiptext tooltip-bottom' id='inputScriptList'>-</span>
          </span>
        </td></tr>
        <tr><th>Language:</th><td>
          <span class='tooltip'>
            <input type='text' id='inputLanguage' oninput='updateLanguage();'/>
            <span class='tooltiptext tooltip-bottom' id='inputLanguageList'>-</span>
          </span>
          </td></tr>
        <tr>
          <th><button onclick='CheckSimilar();' title='Check all words where HarfBuzz output is the same (Compare GIDs is considered)'>Compare and Check</button></th>
          <td>
            <table class='hbtype'>
              <tr>
                <td><input type='checkbox' id='HBCC_count'>🟥Different Glyph Count</input></td>
                <td align='right'><span id='HBCC_count_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_clusters'>🟨Different Clusters</input></td>
                <td align='right'><span id='HBCC_clusters_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_advance'>🟦Different Advance</input></td>
                <td align='right'><span id='HBCC_advance_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_offset'>🟪Different Offset</input></td>
                <td align='right'><span id='HBCC_offset_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_gid' checked>⬜Different GIDs</input></td>
                <td align='right'><span id='HBCC_gid_no'></span></td>
              </tr>
              <tr>
                <td><input type='checkbox' id='HBCC_identical' checked>✅Exact</input></td>
                <td align='right'><span id='HBCC_identical_no'></span></td>
              </tr>
              <tr>
                <td><label for='HBCC_tolerance'>Tolerance:</label><input type='text' id='HBCC_tolerance' oninput='updateTolerance();' title='Tolerance for Offset & Advance&#13;&#10; - either a value in designUnits (e.g. 10), or a percentage (e.g. 10%)'></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <th><button onclick='UpdateDifferences();' title='Regression test:&#13;&#10;For each word where HarfBuzz differs between Font#1 and Font#2 -> toggle the check.&#13;&#10;&#13;&#10;Words left checked will be:&#13;&#10;• requested changes that did not occur&#13;&#10;• unexpected changes'>Update Differences</button></th>
          <td><input type='checkbox' id='HBGIDs' oninput='updateLanguage();' title='Unchecked = ignore glyph ID when comparing; Checked = compare glyph ID in HarfBuzz output'>Compare GIDs</input></td>
        </tr>
        <tr>
          <th><button onclick='CheckDifferentGlyphs();' title='Render the outlines and check any that have large difference area'>Compare Outlines</button></th>
          <td>
            <font color='red'>EXPERIMENTAL</font></br>
            <input type='text' id='HBCGtolerance' title='1000s designUnits^2 area tolerance' value='20'></input></br>
            <input type='checkbox' id='HBCGlive' onchange='updateHBCGlive();'>Show in table</input>
          </td>
        </tr>
      </table>
    </div>
  </div>      

  <div class='dropdown'>
    <button class='dropbtn'>❌Delete</button>
    <div class='dropdown-content'>
    <a href='#' onclick='DeleteDuplicates();' title='Remove all duplicate words'>📚Delete Duplicates</a></br>
    <a href='#' onclick='RemoveUnchecked();' title='Remove all words that are NOT checked (cannot be undone!)'>❌Delete Unchecked</a></br>
    <a href='#' onclick='DeleteAll();' title='Remove all words (cannot be undone!)'>⛔Delete All</a></br>
    </div>
  </div>
<!-- Menus End -->
<div class='vectors' id='vectorDisplay'>
<div id="svgResult"></div>
</div>

<table border=2 cellspacing="8px" width='100%' id='word_list'>
  <tr>
    <th width='16%' id='checkListHeading'>
      # / Note</br><span style='font-size:75%' id='CheckListCount'></span>
    </th>
    <th width='6%'>
      <!--<a href='javascript:void(0)' onclick='toggleHBIcons();'>Diff</a>-->
      Diff
      <div class='dropdown'>
        <button class='dropbtn'>&nbsp;?&nbsp;</button>
        <div class='dropdown-content'>
        <div id='HBIcons' hidden>
        </div>
      </div></div>
    </th>
    <th width='26%' id='fontOneInfoCell'>
      <span id='fontOneInfo'>Drag-and-Drop Font 1</span>
      <div class='dropdown'>
        <button class='dropbtn'>…</button>
        <div class='dropdown-content'>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("100%");'>100%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("200%");'>200%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("300%");'>300%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("400%");'>400%</button></br>
          <button class='dropbtn' style='width:50%' onclick='setFontSize("500%");'>500%</button></br>
        </div>
      </div>
    </th>
    <th width='26%' id='fontTwoInfoCell'>
      <span id='fontTwoInfo'>Drag-and-Drop Font 2
      </span>
      <div class='dropdown'>
        <button class='dropbtn'>…</button>
        <div class='dropdown-content'>
          <button class='dropbtn' style='width:50%' onclick='showFontTwo(false);'>Hide</button></br>
          <button class='dropbtn' style='width:50%' onclick='showFontTwo(true);'>Show</button>
        </div>
      </div>
</th>
    <th width='26%' id='fontOverlap'>Overlap</th>
  </tr>
</table>

</p>

<p>
<button onclick='updateListByField(); window && window.scroll(0,0)'>TOP</button>
<button onclick='updateListNext(); window && window.scroll(0,0)'>Next</button>
</p>
<table width="100%" border=1>
  <tr>
    <td width='22%' id='CheckDragDrop' align='left'>
        <b><span style='background-color:cyan;'>Drag-and-drop CheckList .txt here</span></b>
    </td>
    <td>
    </td>
  </tr>
</table>
</p>

<script>

function isExists(v) {
  if ((typeof(v) === 'object') && (v === null)) return false;
  return typeof(v) !== 'undefined';
}

function isAssigned(obj) {
  if (typeof obj === 'undefined') return false;
  if (obj === null) return false;
  return true;
}

function updateSvg(dive, html) {
  var oldScale = 1;
  var oldTranslate = {x:0, y:0};

  var svge = dive.children[0];
  if (typeof svge !== 'undefined') {
    oldScale = svge.currentScale;
    oldTranslate = svge.currentTranslate;
  }
  dive.innerHTML = html;
  svge = dive.children[0];
  svge.currentScale = oldScale;
  svge.currentTranslate.x = oldTranslate.x;
  svge.currentTranslate.y = oldTranslate.y;
}

function fillOtInfoTables(fontInfo) {
  fontInfo.scripts = new Set();
  fontInfo.languages = new Set();
  fontInfo.features = new Set();

  let doGtable = function(t) {
    if (!t) return;
    if (t.scriptTable) {
      for (const key in t.scriptTable) {
        fontInfo.scripts.add(key);
        for (const val of t.scriptTable[key]) {
          fontInfo.languages.add(val);
        }
      }
    }
    if (t.featureListTable) {
      for (const val of t.featureListTable) {
        fontInfo.features.add(val);
      }
    }
  }
  doGtable(fontInfo.GSUB);
  doGtable(fontInfo.GPOS);
}

class hbFont {
  constructor() {
    this.script = 'latn';
    this.lang   = '';
    this.features = '';
    this.results = {};
    this.results.json = null;
  }
  destroy() {
    this.freeFontBlob();    
  }
  freeFontBlob() {
    this.freeFont();
    this.fileDescription = null;
    delete(this.fontBlob);
  }
  freeFont() {
    this.results = {};
    if (this.font) { this.font.destroy(); delete(this.font); }
    if (this.face) { this.face.destroy(); delete(this.face); }
    if (this.blob) { this.blob.destroy(); delete(this.blob); }
    delete(this.otLayout);
    delete(this.otFont);
    if (this.gc) this.gc.destroy();
    delete this.gc;
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    if (fb) {
      const fontName = FontName.parse(fb)[0];
      //console.log(fontName);
      this.fileDescription = fontName.fullName + '</br>' + fontName.version;
    } else {
      this.fileDescription = '';
    }
    if (!fb) return;
    const otInfo = OTInfo.parse(fb);
    this.fontInfo = otInfo[0];
    fillOtInfoTables(this.fontInfo);
    this.blob = hb.createBlob(this.fontBlob);
    this.face = hb.createFace(this.blob, 0);
    this.font = hb.createFont(this.face);
    const debgTable = this.face.reference_table("Debg");
    if (debgTable) {
      this.debugInfo = JSON.parse(new TextDecoder("utf8").decode(debgTable));
      this.debugInfo = this.debugInfo["com.github.fonttools.feaLib"];
    } else {
      this.debugInfo = null;
    }
    this.otFont = opentype.parse(this.fontBlob);
    this.otLayout = new Layout(this.otFont, 'GPOS');

    this.gc = new GlyphCompareClass();
    this.gc.setFontBlob(this.fontBlob);
    this.gc.setScriptLanguage(this.script, this.lang);
  }
  setScriptLang(script, lang) {
    this.script = script;
    this.lang = lang;

    if (this.gc)
      this.gc.setScriptLanguage(this.script, this.lang);
  }
  shape(txt) {
    if (!this.fontBlob) return;
    var buffer = hb.createBuffer();
    buffer.addText(txt);
    buffer.guessSegmentProperties();
    if ((typeof this.script === 'string') && (this.script.length > 0))
      buffer.setScript(this.script || 'latn');
    if ((typeof this.lang === 'string') && (this.lang.length > 0))
      buffer.setLanguage(this.lang);
    hb.shape(this.font, buffer, this.features);
    const json = buffer.json(this.font);
    this.results.json = json;
    buffer.destroy();
  }
  shapeWithTraceLimits(txt) {
    if (!this.fontBlob) return;
    var buffer = hb.createBuffer();
    buffer.addText(txt);
    buffer.guessSegmentProperties();
    if ((typeof this.script === 'string') && (this.script.length > 0))
      buffer.setScript(this.script || 'latn');
    if ((typeof this.lang === 'string') && (this.lang.length > 0))
      buffer.setLanguage(this.lang);
    let trace = hb.shapeWithTraceLimits(this.font, buffer, this.features);
    const json = buffer.json(this.font);
    this.results.json = json;
    buffer.destroy();
    return trace;
  }
  compare(hb2, toleranceFunction) {
    // Returns bit field:
    // 1 = GID different
    // 2 = Cluster different
    // 4 = Offset different
    // 8 = Advance different (e.g. kerning)
    // 128 = different length
    // 64  = exact
    if (!toleranceFunction) {
      toleranceFunction = function(a,b) {
        return (a !== b);
      }
    }
    if ( (this.results === null) ||
         (this.results.json === null) ||
         (hb2.results === null) ||
         (hb2.results.json === null)
       )
    {
      return -1;
    }
    var idx = 0;
    var res = 0;
    while (true) {
      if (idx >= this.results.json.length) {
        if (idx < hb2.results.json.length) res |= 128;
        break;
      }
      if (idx >= hb2.results.json.length) {
        res |= 128;
        break;
      }
      const g1 = this.results.json[idx];
      const g2 = hb2.results.json[idx];
      if (g1 === null) {
        if (g1 !== null) res |= 128;
        break;
      }
      if (g2 === null) {
        res |= 128;
        break;
      }
      if (g1.g  !== g2.g)  res |= 1;
      if (g1.cl !== g2.cl) res |= 2;

      if (toleranceFunction(g1.dx, g2.dx)) res |= 4;
      if (toleranceFunction(g1.dy, g2.dy)) res |= 4;
      if (toleranceFunction(g1.ax, g2.ax)) res |= 8;
      if (toleranceFunction(g1.ay, g2.ay)) res |= 8;

      idx++;
    }
    if (res === 0) res |= 64;
    return res;
  }
  shapeGlyphCompare(txt) {
    if (!this.gc) return;
    let json = this.gc.shape(txt, this.features);
    this.gc.toPath(json);
  }
  compareOverlap(hb2) {
    if (!this.gc) return undefined;
    if (!hb2.gc) return undefined;
    let overlap = this.gc.overlapArea(hb2.gc);
    return overlap;
  }
  genSVGPath(p64, settings) {
    const size = p64.size();
    for (let i=0;i<size;i++) {
      const point = p64.get(i);
      const x= Number(point.x) *  1;
      const y= Number(point.y) * -1;
      if (i==0)
        this.svgData += `M${x},${y}`;
      else
        this.svgData += `L${x},${y}`;
      point.delete(); //??
    }
    this.svgData += 'z';
  }
  genSVGPaths(ps64, settings) {
    if (!isAssigned(ps64)) return;
    settings = settings || {};
    if (!isExists(settings.mixBlendMode)) settings.mixBlendMode = 'normal';
    this.svgData += '<path ';
    if (settings.id) {
      this.svgData += `id="${settings.id}" `;
    }
    this.svgData += ' style="';
    if (isExists(settings.fillColor)) {
      if (!isExists(settings.fillOpacity)) settings.fillOpacity = 0.5;
      this.svgData += 'fill:'+settings.fillColor
                    +';fill-opacity:'+settings.fillOpacity
    } else {
      this.svgData += ';fill-opacity:0';
    }
    if (isExists(settings.strokeColor)) {
      if (!isExists(settings.strokeOpacity)) settings.strokeOpacity = 1.0;
      if (!isExists(settings.strokeWidth)) settings.strokeWidth = 2;
      this.svgData += ';stroke:'+settings.strokeColor
                    +';stroke-opacity:'+settings.strokeOpacity
                    +';stroke-width:'+settings.strokeWidth
                    +';stroke-linejoin=\'round\''
    }
    if (settings.mixBlendMode !== 'normal')
      this.svgData +=';mix-blend-mode:\''+settings.mixBlendMode+'\''
    
    this.svgData += '" d="';
    const size = ps64.size();
    for (let i=0;i<size;i++) {
      const path = ps64.get(i);
      this.genSVGPath(path, settings);
      path.delete();
    }
    this.svgData += '"/>\r\n';
    return this.svgData;
  }
  genSVGcombined(txt, hb2, hideOverlap) {
    const haveThat = hb2.gc;
    this.svgData = '';
    let svg = '';
    if (!this.gc) return '';
    let jsonThis = this.gc.shape(txt, this.features);
    let p64This = this.gc.toPath(jsonThis);
    let fopac = 1.0;
    if (hb2.gc) {
      let jsonThat = hb2.gc.shape(txt, this.features);
      let p64That = hb2.gc.toPath(jsonThat);
      fopac = hideOverlap ? 1.0 : 0.25;
      if (!hideOverlap) {
        let p64Overlap = this.gc.overlapToCPaths64(hb2.gc);
        svg += this.genSVGPaths(p64Overlap.paths64, {strokeColor:'#f08', strokeWidth:9, strokeOpacity:1, fillColor:'#f08', fillOpacity:1});
        p64Overlap.destroy();
      }
      svg += this.genSVGPaths(p64That.paths64, {fillColor:'#e60', fillOpacity:fopac});
    }
    svg += this.genSVGPaths(p64This.paths64, {fillColor:'#008', fillOpacity:fopac});
    const xmin = -250;
    const ymin = -1800;
    const height = 3000;
    const heightOut = 400;
    const width = 800 /*(window.innerWidth)*/ * height / heightOut * 0.95;
    var bbox = xmin + ' ' + ymin + ' ' +width + ' ' + height;

    svg = '<svg xmlns="http://www.w3.org/2000/svg"'
      + ' height="400" width="800"'
      + ' viewBox="'+bbox+'">' +svg+'</svg>'; 
    updateSvg(svgResult, svg);
    return svg;
  }
  getGlyphName(gid) {
    const glyphData = this.otFont?.glyphs?.get(gid);
    if (!glyphData) return undefined;
    return glyphData.name;
  }
  getGposTableName(idx) {
    if (!this.debugInfo) return null;
    const gpos = this.debugInfo['GPOS'];
    if (!gpos || (gpos.length == 0)) return null;
    const debugData = gpos[idx];
    if (!debugData) return null;
    return debugData[1];
  }
  findGposIndexesFromRegExpList(regExpList) {
    if (!regExpList) return null;
    if (regExpList.length == 0) return null;
    if (!this.debugInfo) return null;
    const gpos = this.debugInfo['GPOS'];
    if (!gpos || (gpos.length == 0)) return null;
    let set = new Set();
    for (const [key,dd] of Object.entries(gpos)) {
      const name = dd[1];
      const keyInt = parseInt(key);
      for (let j=0; j<regExpList.length; j++) {
        const re = regExpList[j];
        if (typeof re === 'object') {
          if (re.test(name)) {
            set.add(keyInt);
            break;
          }
          if (re.test(key)) {
            set.add(keyInt);
            break;
          }
        } else
        if (typeof re === 'number') {
          if (re == keyInt) {
            set.add(keyInt);
            break;
          }
        }
      }
    }
    return set;
  }
  findGidIndexesFromRegExpList(regExpList) {
    if (!regExpList) return null;
    if (regExpList.length == 0) return null;
    let set = new Set();
    const max = this.otFont?.glyphs?.length;
    if (!max) return null;
    for (let gid=0; gid<max; gid++) {
      const name = this.getGlyphName(gid);
      const gidString = String(gid);
      for (let j=0; j<regExpList.length; j++) {
        const re = regExpList[j];
        if (typeof re === 'object') {
          if (re.test(name)) {
            set.add(gid);
            break;
          }
          if (re.test(gidString)) {
            set.add(gid);
            break;
          }
        } else
        if (typeof re === 'number') {
          if (re == gid) {
            set.add(gid);
            break;
          }
        }
      }
    }
    return set;
  }
}

var hbf1 = new hbFont;
var hbf2 = new hbFont;

class wordEntryClass {
  constructor(line) {
    const tempArray = line.split('\t');
    this.word = tempArray[0];
    this.note = tempArray[1] || '';
    this.diff = tempArray[2] || '';
    this.checked = false;
    //??//this.checked = (tempArray[2] === 'x') || (tempArray[2] === 'X'); //??
  }
  getWord()     { return this.word; }
  getChecked()  { return this.checked; }
  setChecked(isChecked) { this.checked = isChecked; }
  setNote(txt)  { this.note = txt; }
  getNote()     { return this.note; }
  getDiff()     { return this.diff; }
  setDiff(diff) { this.diff = diffValueToUnicode(diff); }
  setGposData(gpd) { this.gposData = gpd; }
  getGposData() { return this.gposData; }
  setGidData(gids) { this.gidData = gids; }
  getGidData() { return this.gidData; }
  // The line for the check list file output
  getLine() {
    var txt = this.word + '\t' + (this.note || '') + '\t' + (this.diff || '');
    while (txt.endsWith('\t')) {
      txt = txt.slice(0, txt.length-1);
    }
    return txt;
  }
  updateDifferenceIcons(diffs) {
    // remove icons first...
    // and append
    this.note = diffValueToNote(this.note, diffs);
  }
  cacheClear() {
    delete this.diffArea;
    delete this.gposData;
    delete this.gidData;
  }
  calcDifferenceArea(hbf1, hbf2) {
    hbf1.shapeGlyphCompare(this.word);
    hbf2.shapeGlyphCompare(this.word);
    let da = 0;
    let diffs = hbf1.compareOverlap(hbf2);
    if (diffs) da = Math.round(diffs.fill) / 1000.0;
    this.diffArea = da;
    return da;
  }
  getDifferenceArea() { return this.diffArea; }
  getDifferenceAreaCalc(hbf1, hbf2) {
    if (typeof this.diffArea !== 'undefined') return this.diffArea;
    return this.calcDifferenceArea(hbf1, hbf2);
  }
  updateGids(hbo) {
    if (this.gidData) return;
    const json = hbo.results.json;
    if (!json) return;
    let gids = new Set();
    for (let idx=0; idx<json.length; idx++) {
      const x = json[idx];
      gids.add(x.g);
    }
    this.gidData = gids;
  }
}

var wordList = []; // An array of wordEntry objects

function fontsHaveChanged() {
  const size = wordList.length;
  for (let i=0; i<size; i++) {
    wordList[i].cacheClear();
  }
}

function buildListFromFileContents(txt)
{
  var lines = txt.split(/\r?\n+/g);
  var tempWordList = [];  // Start empty
  var i = 0;
  while (i < lines.length) {
    const wordEntry = new wordEntryClass(lines[i]);
    if (wordEntry.getWord().length > 0) {
      tempWordList.push(wordEntry);
    }
    i++;
  }
  return tempWordList;
}

function getWordCheckCount() {
  var count = 0;
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) count++;
    i++;
  }
  return count;
}

function findWordInList(theList, theWord, cache)
{
  if (cache === undefined) {
    var i = 0;
    while (i < theList.length) {
      if (theList[i].getWord() === theWord) {
        return i;
      }
      i++;
    }
    return -1;
  }
  if (!cache._filled) {
    const size = theList.length;
    for (let i=0; i<size; i++) {
      const word = theList[i].getWord();
      if (!cache[word])
        cache[word] = i;
    }
    cache._filled = true;
  }
  const ce = cache[theWord];
  if (ce === undefined)
    return -1;
  return ce;
}

function addToList(theList, wordListEntry, cache) {
  theList.push(wordListEntry);
  cache[wordListEntry.getWord()] = theList.length - 1;
} 

function updateCheckListCount() {
  var count = getWordCheckCount();
  CheckListCount.innerHTML = 'Checked '+count+'/'+wordList.length;
}

function checkBothFontsLoaded() {
  var res = true;
  if (!hbf1.fileDescription) res = false;
  if (!hbf2.fileDescription) res = false;
  if (hbf1.fileDescription === '') res = false;
  if (hbf2.fileDescription === '') res = false;
  if (hbf1.fileDescription === hbf2.fileDescription) res = false;
  if (!res)
  {
    window.alert('Please load two fonts to compare');
  }
  return res;
}

function showHideColumn(colNo, doShow) {
  var stl;
  if (doShow)
    stl = 'table-cell';
  else
    stl = 'none';
  const rows = word_list.getElementsByTagName('tr');
  const size = rows.length;
  for (let row=1; row<size; row++) {
    const cells = rows[row].getElementsByTagName('td');
    cells[colNo].style.display = stl;
  }
}

function showFontTwo(doShow) {
  if (doShow) {
    checkListHeading.style.width = '16%';
    // diff = '6%'
    fontOneInfo.style.width = '26%';
    fontTwoInfoCell.style.width = '26%';
    fontOverlap.style.width = '26%';
    fontOverlap.hidden = false;
    showHideColumn(3, true);
    showHideColumn(4, true);
  } else {
    checkListHeading.style.width = '39%';
    // diff = '6%'
    fontOneInfo.style.width = '40%';
    fontTwoInfoCell.style.width = '10%';
    fontOverlap.style.width = '5%';
    fontOverlap.hidden = true;
    showHideColumn(3, false);
    showHideColumn(4, false);
  }
}

function toggleVisibilityLabel(ele, href) {
  ele.hidden = !ele.hidden;
  let txt = href.text;
  if (ele.hidden)
    href.text = txt.replace('Hide', 'Show');
  else
    href.text = txt.replace('Show', 'Hide');
}

function toggleHBIcons() {
  HBIcons.innerHTML = '<p align="left">'+
    hb_icons.identical[0] + 'exact</br>'+
    //hb_icons.gid[0]       + 'gids</br>'+
    hb_icons.count[0]     + 'count</br>'+
    hb_icons.cluster[0]   + 'clu</br>'+
    hb_icons.advance[0]   + 'adv</br>'+
    hb_icons.offset[0]    + 'ofs</br>'+
    "</span>";
  HBIcons.hidden = !HBIcons.hidden;
}

function triCb(cb) {
  if (cb.readOnly) cb.checked=cb.readOnly=false;
  else if (!cb.checked) cb.readOnly=cb.indeterminate=true;
}

function iterateGtable(gtable, theKey, outputset) {
  if (!gtable) return;
  const scriptTable = gtable.scriptTable;
  if (!scriptTable) return;
  if (!scriptTable[theKey]) return;
  for (const y of scriptTable[theKey]) {
    outputset.add(y);
  }
}

function mapToQuotes(list) {
  return '"'+[...list].sort().join('","')+'"';
}

function getScriptLanguage(fontInfo, filterScript) {
  let scripts = '';
  let languages = '';
  if (fontInfo) {
    if (fontInfo.scripts.size > 0)
      scripts = mapToQuotes(fontInfo.scripts);

    let languageSet = fontInfo.languages;
    if (filterScript !== '') {
      filterScript = filterScript.toLowerCase();
      languageSet = new Set();
      iterateGtable(fontInfo.GSUB, filterScript, languageSet);
      iterateGtable(fontInfo.GPOS, filterScript, languageSet);
    }
    if (languageSet.size > 0)
      languages = mapToQuotes(languageSet);
  }
  return {
    scripts: scripts,
    languages: languages,
  };
}

// Update the document language tag, and the HarfBuzz values
function updateLanguage() {
  const script = inputScript.value;
  const language = inputLanguage.value;

  inputScriptList.innerText = '(empty)';
  inputLanguageList.innerText = '(empty)';

  const details1 = getScriptLanguage(hbf1.fontInfo, script);
  const details2 = getScriptLanguage(hbf2.fontInfo, script);
  let scripts = details1.scripts;
  if (scripts === '') {
    scripts = details2.scripts;
    if (scripts !== '') scripts = 'FONT2: '+scripts;
  }
  if ((details2.scripts !== '') && (details2.scripts !== details1.scripts)) {
    scripts = 'FONT1: '+details1.scripts + '\r\n'+ 'FONT2: '+details2.scripts;
  }
  if (scripts !== '') inputScriptList.innerText = scripts;

  let languages = details1.languages;
  if (languages === '') {
    languages = details2.languages;
    if (languages !== '') languages = 'FONT2: '+languages;
  }
  if ((details2.languages !== '') && (details2.languages !== details1.languages)) {
    languages = 'FONT1: '+details1.languages + '\r\n' + 'FONT2: '+details2.languages;
  }
  if (languages !== '') inputLanguageList.innerText = languages;

  // TODO: FEATURES

  document.documentElement.setAttribute('lang', HTMLLang.value);
  updateHarfBuzzScriptLanguage();
}

function ClearCheckList() {
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(false);
    i++;
  }
  resetCheckListChanged();
}

function ClearCheckListUser() {
  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Clear all?')) return;
  }
  ClearCheckList();
  updateCheckListCount();
  updateListByField();
}

function CheckAllList() {
  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Set all?')) return;
  }
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(true);
    i++;
  }
  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
}

function InvertCheckList() {
  const size = wordList.length;
  for (let i=0; i<size; i++) {
    wordList[i].setChecked(!wordList[i].getChecked());
  }
  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
}

function GetRadioValue(id) {
  const radios = document.getElementsByName(id);
  for (var i=0, rl=radios.length; i<rl; i++) {
    if (radios[i].checked) {
      return radios[i].value;
    }
  }
  return null;
}

function findInExpList(expList, value) {
  for (let i=0; i<expList.length; i++) {
    const re = expList[i];
    if (re.test(value)) return true;
  }
  return false;
}

function createRegExp(txt) {
  if (!txt || (txt === '')) return null;
  try {
    re = new RegExp(txt);
  } catch (e) {
    window.alert(e.message);
    return null;
  }
  return re;
}

function createRegExpList(txt) {
  if (!txt || (txt === '')) return null;
  const txtList = txt.split(',');
  const expList = [];
  const isInteger = new RegExp('^[0-9]+$');
  for (let i=0; i<txtList.length; i++) {
    const entry = txtList[i];
    if (isInteger.test(entry)) {
      expList.push(parseInt(entry));
    } else {
      try {
        expList.push( new RegExp(entry) );
      } catch (e) {
        window.alert(e.message);
        return null;
      }
    }
  }
  return expList;
}

function isHarfBuzzMessageImportant(msg) {
  const set = [
    // GSUB operations
    'replacing',   'replaced',
    'deleting',    'deleted',
    'multiplying', 'multiplied',
    'ligating',    'ligated',

    // GPOS operations
    'kerning',     'kerned',
    'attaching',   'attached',
    'positioning', 'positioned',
  ];
  const size = set.length;
  for (let i=0;i<size;i++) {
    if (msg.includes(set[i])) return true;
  }
  return false;
}

function findLastLookup(trace, index) {
  let res = {};
  if (index >= trace.gpos_point) res.stage = 'GPOS';
  else if (index >= trace.gsub_point) res.stage = 'GSUB';
  while (!res.lastIndex && (index > 0)) {
    let debugInfo = null;
    const message = trace[index].m;
    const m3 = message.match(/^start lookup (\d+) feature '(\w+)'/);
    const m4 = message.match(/^recursing to lookup (\d+)/);
    if (m3) {
      res.lastIndex = parseInt(m3[1], 10);
    }
    if (m4) {
      res.lastIndex = parseInt(m4[1], 10);
    }
    index--;
  }
  res.index = index;
  return res;
}

function extractGposData(trace) {
  if (!trace || !trace.gpos_point) return null;
  let idx = trace.gpos_point;
  let gposTable;
  const max = trace.length;
  const res = [];
  while (idx < max) {
    const tr = trace[idx];
    const msg = tr?.m;
    const m3 = msg.match(/^start lookup (\d+) feature '(\w+)'/);
    const m4 = msg.match(/^recursing to lookup (\d+)/);
    if (m3) { gposTable = parseInt(m3[1], 10); }
    if (m4) { gposTable = parseInt(m4[1], 10); }

    if (!m3 && !m4) {
      // Pull out glyph index figures to establish which GIDs affected
      // Scan for ' at ...' in the tr.m field
      var sets = msg.match(/ glyph at [\d,]+/g);
      if (sets) {
        if (!res[gposTable])
          res[gposTable] = new Set();
        let i = 0;
        while (i < sets.length) {
          const indices = sets[i].match(/\d+/g);
          let j = 0;
          while (j < indices.length) {
            const n = parseInt(indices[j], 10);
            res[gposTable].add(tr?.t[n]?.g);
            j++;
          }
          i++;
        }
      }
    }
    idx++;
  }
  return res;
}

// Build array of [GID][GPOS] = count
function addToGposGrid(grid, gposData, phrase) {
  if (!gposData) return;
  if (!grid.gpos) grid.gpos = []; // A list of all the GIDs in the output
  if (!grid.gids) grid.gids = [];
  gposData.forEach( function(item, gposIndex) {
    if (!grid.gpos[gposIndex]) grid.gpos[gposIndex] = 0;
    grid.gpos[gposIndex]++;

    item.forEach( function(item) {
      if (!grid.gids[item]) grid.gids[item] = 0;
      grid.gids[item]++;

      if (!grid[item]) grid[item] = [];
      if (!grid[item][gposIndex]) grid[item][gposIndex] = 0;
      grid[item][gposIndex]++;
    });
  });
  return grid;
}

async function processChecklistGpos() {
  const size = wordList.length;
  let et = new ElapsedTimer();
  gposGrid = [];
  window.gposGrid = gposGrid;
  let count = 0;
  let aborted = false;

  startLongRunning();
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    if (we.getChecked()) {
      const phrase = we.getWord();
      if (!we.getGposData()) {
        let trace = hbf1.shapeWithTraceLimits(phrase);
        we.updateGids(hbf1);
        we.setGposData(extractGposData(trace));
      }
      addToGposGrid(gposGrid, we.getGposData(), phrase);
      count++;
    }
    if (et.elapsed()) {
      updateStatusMessage(i, 0, size);
      //mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      aborted = true;
      break;
    }
  } 
  doneLongRunning();

  if (aborted) return;
  if (!count) {
    window.alert('Nothing checked!');
    return;
  }

  let html = 'GID/GPOS analytics\r\n\r\n';

  const gposSet = gposGrid.gpos;
  const gidSet  = gposGrid.gids;
  if (!gposSet) return;
  html += '"GID","GlyphName"';
  gposSet.forEach( function(item, gpos) {
    const gposName = hbf1.getGposTableName(gpos);
    if (gposName)
      html += `,"${gpos}:${gposName}"`;
    else
      html += `,${gpos}`;
  });
  html += `,"TOTAL"`;
  html += '\r\n';

  gposGrid.forEach( function(gidItem, gid) {
    const gidName = hbf1.getGlyphName(gid);
    html += `${gid}`;
    if (gidName)
      html += `,"${gidName}"`;
    else
      html += `,`;

    gposSet.forEach( function(gposItem, gpos) {
      const gidCount = gidItem[gpos];
      if (gidCount)
        html += `,${gidCount}`;
      else
        html += `,`;
    });

    html += `,${gposGrid.gids[gid]}`;
    html += '\r\n';
  });

  html += '"TOTAL",';
  gposSet.forEach( function(item, gpos) {
    html += `,${item}`;
  });
  html += '\r\n';

  // Add the Font Details
  html += '\r\n';
  html += `"FONT","${hbf1.fontNames.fullName}","${hbf1.fontNames.version}"`;

  // Add the Word List stats
  html += '\r\n';
  html += `"WORDLIST",${wordlist_filename}\r\n`;
  html += `"CHECKED",${getWordCheckCount()}`;

  html += '\r\n\r\n';
  // Sorted outputs for GID and GPOS
  let arr = [];

  html += '"----------------"\r\n';
  html += '"GPOS Count Order"\r\n';
  html += '"----------------"\r\n';
  html += '"GPOS","TableName","Count"\r\n';
  gposSet.forEach((v,k)=> arr.push({key:k, val:v}));
  arr.sort((a,b) => {
    if (a.val > b.val) return -1;
    if (a.val < b.val) return 1;
    if (a.key > b.key) return 1;
    if (a.key < b.key) return -1;
    return 0;
  });
  arr.forEach((v) => {
    html += `${v.key},`;
    const gposName = hbf1.getGposTableName(v.key);
    if (gposName)
      html += `"${gposName}"`;
    html += `,${v.val}\r\n`;
  });
  html += '\r\n';

  html += '"---------------"\r\n';
  html += '"GID Count Order"\r\n';
  html += '"---------------"\r\n';
  html += '"GID","GlyphName","Count"\r\n';
  arr = [];
  gidSet.forEach((v,k) => arr.push({key:k, val:v}));
  arr.sort((a,b) => {
    if (a.val > b.val) return -1;
    if (a.val < b.val) return 1;
    if (a.key > b.key) return 1;
    if (a.key < b.key) return -1;
    return 0;
  });
  arr.forEach((v) => {
    html += `${v.key},`;
    const gidName = hbf1.getGlyphName(v.key);
    if (gidName)
      html += `"${gidName}"`;
    html += `,${v.val}\r\n`;
  });
  html += '\r\n';

  saveTextToFile(html, 'Glyph-GPOS-Analytics.'+DateTimeForFilename()+'.txt');
}


async function CheckmarkRegExp() {
  // Glyph Name or GPOS table name
  const opType = GetRadioValue('regExpOp');
  const opCheck   = (opType === 'check');
  const opUncheck = (opType === 'uncheck');
  const opInvert  = (opType === 'invert');

  var count = 0;
  const size = wordList.length;
  let et = new ElapsedTimer();

  const expNote = createRegExp(regExpNotes.value);
  const expWord = createRegExp(regExpWord.value);
  const expListGlyph = createRegExpList(regExpGlyph.value);
  const gidSet = hbf1.findGidIndexesFromRegExpList(expListGlyph);
  const expListGpos  = createRegExpList(regExpGpos.value);
  const gposSet = hbf1.findGposIndexesFromRegExpList(expListGpos);

  if (!expNote && !expWord && !expListGlyph && !gposSet) {
    window.alert('Please fill in at least one field!');
    return;
  }


  startLongRunning();
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    const phrase = we.getWord();
    let match = false;

    let matchesNote = true;
    if (expNote) matchesNote = expNote.test(we.getNote());
    let matchesWord = true;
    if (expWord) matchesWord = expWord.test(phrase);


    let matchesGlyph = true;
    let matchesGpos = true;

    let trace = null;

    if (expListGlyph || gposSet) {
      if (!gposSet) {
        // Straight shape to get gids
        if (!we.getGidData()) {
          hbf1.shape(phrase)
          we.updateGids(hbf1);
        }
      } else {
        // Full trace to extract GPOS table data as well as gids
        if (!we.getGposData()) {
          trace = hbf1.shapeWithTraceLimits(phrase);
          we.updateGids(hbf1);
          we.setGposData(extractGposData(trace));
        }
      }

      if (expListGlyph) {
        // Check whether the glyphs name(s) or number(s) appear in the shaped output
        matchesGlyph = false;
        /*
        const json = hbf1.results.json;
        for (let idx=0; idx<json.length; idx++) {
          const x = json[idx];
          // if (x.g) found in the list of expList...
          if (findInExpList(expListGlyph, x.g)) {
            matchesGlyph = true;
            break;
          }
          const glyphName = hbf1.getGlyphName(x.g);
          if (glyphName && findInExpList(expListGlyph, glyphName)) {
            matchesGlyph = true;
            break;
          }
        }
        */
        const gids = we.getGidData();
        gids.forEach( function(key) {
          if (!matchesGlyph && gidSet.has(key)) {
            matchesGlyph = true;
          }
        });
      }

      if (gposSet) {
        // Search for GPOS table that had an effect on the output that is in expListGpos
        matchesGpos = false;
        /*
        const max = trace.length;
        let j = max - 1;
        const gpos_point = trace.gpos_point;
        while (!matchesGpos && (j >= gpos_point)) {
          const msg = trace[j]?.m;
          if (msg && isHarfBuzzMessageImportant(msg)) {
            // now find the start to extract the table number...
            const lu = findLastLookup(trace, j);
            j = lu.index;
            if (lu.lastIndex) {
              let li = parseInt(lu.lastIndex);
              if (gposSet.has(li)) {
                matchesGpos = true;
              }
            }
          }
          j--;
        }
        */
        const gposData = we.getGposData();
        gposData.forEach( function(item, index) {
          if (gposSet.has(index)) {
            matchesGpos = true;
          }
        });
      }
    }

    match = matchesNote && matchesWord && matchesGlyph && matchesGpos;

    if (match) {
      count++;
      if (opCheck)
        we.setChecked(true);
      else if (opUncheck)
        we.setChecked(false);
      else if (opInvert)
        we.setChecked(!we.getChecked());
    }

    if (et.elapsed()) {
      updateStatusMessage(i, count, size);
      //mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      break;
    }
  }

  updateCheckListCount();
  checkListHasChanged();
  updateListByField();
  doneLongRunning();
  window.alert('Found '+count+' matches');
}

var AbortLongRunning = false;

function startLongRunning() {
  AbortLongRunning = false;
  AbortButton.hidden = false;
  ddProgress.style.display = 'block';
}

function doAbortLongRunning() {
  AbortLongRunning = true;
}

function doneLongRunning() {
  AbortButton.hidden = true;
  ddProgress.style.display = '';
}

function isLongRunning() {
  return !AbortButton.hidden;
}

// polyfill for scheduler.yield
globalThis.scheduler = globalThis.scheduler || {};
globalThis.scheduler.yield = 
  globalThis.scheduler.yield || 
  (() => new Promise((r) => setTimeout(r, 0)));

class ElapsedTimer {
  constructor(t=32) {
    this.max = t;
    this.next = performance.now() + t;
  }
  elapsed() {
    const now = performance.now();
    if (now < this.next) return false;
    while (now > this.next) this.next += this.max;
    return true;
  }
}

function updateStatusMessage(i, foundCount, total) {
  if (i <= 0)
    statusUpdate.innerHTML = '-';
  else {
    let html = '<span><font color="red">'+i + '/'+ total+'</font></span>'
    if (foundCount > 0) {
      html += '</br>'+foundCount + ' found';
    }
    statusUpdate.innerHTML = html;
  }
}

function updateBitCountsOne(t, bits, v) {
  if ((bits & v) !== 0) {
    t[v] = (t[v] || 0) + 1;
  }
}

function updateBitCounts(t, bits) {
  updateBitCountsOne(t,bits,hb_icons.count[2]);
  updateBitCountsOne(t,bits,hb_icons.cluster[2]);
  updateBitCountsOne(t,bits,hb_icons.advance[2]);
  updateBitCountsOne(t,bits,hb_icons.offset[2]);
  updateBitCountsOne(t,bits,hb_icons.gid[2]);
  updateBitCountsOne(t,bits,hb_icons.identical[2]);
}

function mapCountsToDisplay(t) {
  HBCC_count_no.innerHTML     = t[hb_icons.count[2]] || '';
  HBCC_clusters_no.innerHTML  = t[hb_icons.cluster[2]] || '';
  HBCC_advance_no.innerHTML   = t[hb_icons.advance[2]] || '';
  HBCC_offset_no.innerHTML    = t[hb_icons.offset[2]] || '';
  HBCC_gid_no.innerHTML       = t[hb_icons.gid[2]] || '';
  HBCC_identical_no.innerHTML = t[hb_icons.identical[2]] || '';
}

async function CheckSimilar() {
  const total = wordList.length;
  let i = 0;
  var bits = 0;
  var bit_counts = [];

  if (HBCC_count.checked)     bits |= hb_icons.count[2];
  if (HBCC_clusters.checked)  bits |= hb_icons.cluster[2];
  if (HBCC_advance.checked)   bits |= hb_icons.advance[2];
  if (HBCC_offset.checked)    bits |= hb_icons.offset[2];
  if (HBCC_gid.checked)       bits |= hb_icons.gid[2];
  if (HBCC_identical.checked) bits |= hb_icons.identical[2];


  if (isLongRunning()) return; // Something in progress already

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }

  startLongRunning();
  const checkGIDs    = HBGIDs.checked;

  updateHarfBuzzScriptLanguage();

  var checkCount = 0;
  updateStatusMessage(i, checkCount, total);

  let et = new ElapsedTimer();

  for (let i=0; i<total; i++) {
    const phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    wordList[i].updateGids(hbf1);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2, tolCompare);
    updateBitCounts(bit_counts, diff);
    if ((diff & bits) != 0) {
      wordList[i].setChecked(true);
      checkCount++;
    }
    wordList[i].setDiff(diff);  // Update the difference field

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      mapCountsToDisplay(bit_counts);
      await scheduler.yield();      
    }
    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  mapCountsToDisplay(bit_counts);
  doneLongRunning();
}

function updateHBCGlive() {
  updateListByIndex(start_index);
}

async function CheckDifferentGlyphs(onCompletion) {
  let i = 0;
  const total = wordList.length;
  if (isLongRunning()) return;

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a long, LONG time. Continue?')) return;
  }
  startLongRunning();
  let et = new ElapsedTimer();

  updateHarfBuzzScriptLanguage();

  const tolerance = parseFloat(HBCGtolerance.value);

  let checkCount = 0;
  updateStatusMessage(i, checkCount, total);

  for (let i=0; i<total; i++) {
    let diffs = wordList[i].getDifferenceAreaCalc(hbf1, hbf2);
    if (diffs && !onCompletion) {
      if (diffs >= tolerance) {
        wordList[i].setChecked(true);
        checkCount++;
      }      
    }

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      await scheduler.yield();
    }
    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  if (onCompletion) {
    onCompletion();
  }
  doneLongRunning();
}

function CheckNotes() {
  var i = 0;
  var count = 0;
  while (i < wordList.length) {
    var note = wordList[i].getNote();
    if (note && (note.length > 0)) {
      wordList[i].setChecked(true);
      count++;
    }
    i++;
  }
  if (count > 0)
    checkListHasChanged();
  updateListByIndex(1);
  updateCheckListCount();
  window.scroll(0,0);
  updateStatusMessage(-1);
  window.alert('Checked '+count+' words');
}

function updateHarfBuzzScriptLanguage() {
  const script = inputScript.value;
  const language = inputLanguage.value;
  hbf1.setScriptLang(script, language);
  hbf2.setScriptLang(script, language);
}

async function UpdateDifferences() {
  let i = 0;
  const total = wordList.length;

  if (isLongRunning()) return;
  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }
  startLongRunning();

  const checkGIDs = HBGIDs.checked;

  updateHarfBuzzScriptLanguage();

  let checkCount = 0;
  updateStatusMessage(i, checkCount, total);

  let et = new ElapsedTimer();

  for (let i=0; i<total; i++) {
    const phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    wordList[i].updateGids(hbf1);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2, tolCompare);
    const theSame = ((diff == 1) && checkGIDs) || (diff == 0) || (diff == 64);
    if (!theSame) {
      wordList[i].setChecked(!wordList[i].getChecked());
      checkCount++;
    }

    if (et.elapsed()) {
      updateStatusMessage(i, checkCount, total);
      await scheduler.yield();      
    }

    if (AbortLongRunning) {
      break;
    }
  }
  checkListHasChanged();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
  doneLongRunning();
}

async function RemoveUnchecked() {
  if (isLongRunning()) return;
  if (!window.confirm('Delete all unchecked words?\r\nCannot be undone!!!')) return;
  var i = 0;
  var counter = 0;
  var deletedCount = 0;
  var newWordList = [];
  const size = wordList.length;

  startLongRunning();
  let et = new ElapsedTimer();

  for (let i=0; i<size; i++) {
    counter++;
    const wle = wordList[i];
    if (wle.getChecked()) {
      newWordList.push(wle);
    } else {
      deletedCount++;      
    }
    if (et.elapsed()) {
      updateStatusMessage(i, deletedCount, size);
      await scheduler.yield();
    }
    if (AbortLongRunning) {
      break;
    }
  }

  wordList = newWordList; // Assign the new updated list
  if (typeof wordlist_filename === 'string') {
    if (!wordlist_filename.endsWith('(edited)')) wordlist_filename = wordlist_filename + ' (edited)';
  }
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
  window.alert('Deleted '+deletedCount);
  doneLongRunning();
}

function DeleteDuplicates() {
  if (!window.confirm('Delete duplicate words?\r\nCannot be undone!!!')) return;
  const size = wordList.length;
  var res = [];
  var count = 0;
  var cache = {};
  for (let i=0; i<size; i++) {
    const we = wordList[i];
    const wei = findWordInList(res, we.getWord(), cache);
    if (wei >= 0) {
      // already there. Check the notes and checkmark
      res[wei].setChecked(res[wei].getChecked() || we.getChecked());
      const note = we.getNote();
      if (note !== '') {
        if (res[wei].getNote() === '')
          res[wei].setNote(note);
        else
          res[wei].setNote(res[wei].getNote() + '/' + we.getNote());
      }
      count++;
    } else {
      addToList(res, we, cache);
    }
  }
  wordList = res;
  if (count > 0) checkListHasChanged();
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
  window.alert('Duplicates '+count);
}


function _updateAfterSort() {
  checkListHasChanged();
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
}

function SortWordList(sortByNote, byChecked) {
  if (!window.confirm('Sort word list?\r\nCannot be undone!!!')) return;
  var compareWord = function(a,b) {
    const aw = a.getWord();
    const bw = b.getWord();
    if (aw < bw) return -1;
    if (aw > bw) return 1;
    return 0;
  }
  var compareNote = function(a,b) {
    const aw = a.getNote();
    const bw = b.getNote();
    if (aw < bw) {
      if (aw === '') return 1;
      return -1;
    }
    if (aw > bw) {
      if (bw === '') return -1;
      return 1;
    }
    return compareWord(a, b);
  }
  var compareCheck = function(a,b) {
    if (a.getChecked()) {
      if (b.getChecked())
        return compareWord(a,b);
      return -1;
    }
    if (b.getChecked()) {
      return 1;
    }
    return compareWord(a,b);
  }
  if (byChecked)
    wordList.sort(compareCheck);
  else
  if (sortByNote)
    wordList.sort(compareNote);
  else
    wordList.sort(compareWord);
  _updateAfterSort();
}

function SortWordListArea() {
  if (!window.confirm('Sort word list?\r\nCannot be undone!!!')) return;
  HBCGlive.checked = true;
  CheckDifferentGlyphs( () => {
    var compare = function(a,b) {
      let da = a.getDifferenceArea();
      let db = b.getDifferenceArea();
      if (da > db)
        return -1;
      if (da < db)
        return 1;
      const aw = a.getWord();
      const bw = b.getWord();
      if (aw < bw) return -1;
      if (aw > bw) return 1;
      return 0;
    }
    wordList.sort(compare);
    _updateAfterSort();    
  });
}

function DeleteAll() {
  if (!window.confirm('Delete all words?\r\nCannot be undone!!!')) return;
  wordList = [];
  UpdateWordCount();
  updateCheckListCount();
  updateListByIndex(1);
  updateStatusMessage(-1);
}

// See: https://github.com/MattMatic/unique-words
function findUniqueWords(input, options) {
  let lang = options.language;
  if (lang === '') lang = 'en';
  let segmenter = new Intl.Segmenter(lang, {granularity: 'word'});
  let segments = segmenter.segment(input);
  let words = {};
  for (let {segment, index, isWordLike} of segments) {
    if (isWordLike) {
      let hasNumbers =  /\d/.test(segment);
      if (!hasNumbers || options.numbers) {
        if (options.normalize) segment = segment.normalize();
        words[segment] = true;  // Assimilate a list
      }
    }
  }
  var res = [];
  for (const word in words) {
    res.push(word);
  }
  if (options.sort) {
    res.sort();
  }
  return res;
}

function assimilateText(input) {
  var options = {
    language: HTMLLang.value,
    sort: true,
    numbers: false,
  }
  var words = findUniqueWords(input, options);

  const wordsLength = words.length;
  const inputShort = input.substring(1, 40);
  const confirmMessage = 'Paste '+wordsLength+' unique words from "'+inputShort+'..." ?';
  if (!window.confirm(confirmMessage)) {
    return;
  }
  var count = 0;
  var cache = {};
  words.forEach( (w) =>  {
    var mi = findWordInList(wordList, w, cache);
    if (mi >= 0) {
      // Found the word
    } else {
      const newEntry = new wordEntryClass(w);
      count++;
      newEntry.setChecked(true);
      addToList(wordList, newEntry, cache);
    }
  });
  checkListHasChanged();
  updateCheckListCount();
  updateListByField();
  UpdateWordCount();  
  window.alert(count+' new words were added');
}

async function pasteUniqueWords() {
  // Access clipboard and use Intl.segmenter to pull out words
  let input = '';
  try {
    const clipboardContents = await navigator.clipboard.read();
    for (const item of clipboardContents) {
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const blobText = await blob.text();
        assimilateText(blobText);
      }
    }
  } catch (error) {
    console.log(error.message);
  }
  if (!wordlist_filename) wordlist_filename = '(clipboard)';
}

var hbfcw = null;
var ffftw = null;
var api = {};

function prepareApi() {
  api = {};
  api.transfer = {}
  api.transfer.script = inputScript.value;
  api.transfer.language = inputLanguage.value;
  api.transfer.direction = null;
  api.transfer.fontBlob1 = hbf1.fontBlob;
  api.transfer.fontBlob2 = hbf2.fontBlob;
  api.transfer.wordList = [];
  api.transfer.checkList = [];
  var i = 0;
  const size = wordList.length;
  while (i < size) {
    const word = wordList[i].word;
    if (wordList[i].getChecked()) {
      api.transfer.checkList.push(word);
    }
    api.transfer.wordList.push(word);
    i++;
  }
}

function openFontCompareTool() {
  prepareApi();
  if (!hbfcw || hbfcw.closed) {
    var hbfc_url;
    if (window.location.hostname === 'localhost')
      hbfc_url = '../hbfontcompare/index.html';
    else
      hbfc_url = 'https://mattmatic.github.io/hbfontcompare/index.html';
    hbfcw = window.open(hbfc_url, 'mattmatic.hbfontcompare')
  } else {
    hbfcw.updateTransfer(api.transfer);
    hbfcw.focus();
  }
}

function openFontForceFieldTool() {
  prepareApi();
  if (!ffftw || ffftw.closed) {
    var ffft_url;
    if (window.location.hostname === 'localhost')
      ffft_url = '../font-force-field/index.html';
    else
      ffft_url = 'https://mattmatic.github.io/font-force-field/index.html';
    ffftw = window.open(ffft_url, 'mattmatic.font-force-field')
  } else {
    ffftw.updateTransfer(api.transfer);
    ffftw.focus();
  }
}

function acquireFontAndLists(w) {
  if (!w?.api?.transfer) return;
  const xfer = w.api.transfer;  // Use this as a conduit for values to be passed in here
  inputScript.value = xfer.script;
  inputLanguage.value   = xfer.language;
  wordlist_filename = xfer.wordListFileName;
  
  // xfer.wordList
  wordList = [];
  const size = xfer.wordList.length;
  for(let i = 0; i<size; i++) {
    const xwe = xfer.wordList[i];
    var wordEntry = new wordEntryClass(xwe.word);
    wordEntry.checked = xwe.checked;
    wordEntry.note = xwe.note;
    wordList.push(wordEntry);    
  }
  applyFontX(null, 'Test_Font_1', fontOneInfo, hbf1, xfer.fontBlob);
  // Not font 2...
  updateLanguage();
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(start_index);
  window.scroll(0,0);
  disableSaveButton();
}

function updateTransfer(xfer) {
  acquireFontAndLists(window.opener);
}


function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function saveTextToFile(txt, filename) {
  var bb = new Blob([txt], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = filename;
  a.href = window.URL.createObjectURL(bb);
  a.target='_blank';
  a.click();
}

function DownloadCheckList() {
  var txt = '';
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) {
      txt = txt + wordList[i].getLine()+'\n';
    }
    i++;
  }
  saveTextToFile(txt, 'CheckList.'+DateTimeForFilename()+'.txt');
}


// Ref: https://gist.github.com/Explosion-Scratch/357c2eebd8254f8ea5548b0e6ac7a61b
function compressStringToArrayBuffer(txt, encoding = 'gzip') {
  const byteArray = new TextEncoder().encode(txt);
  const cs = new CompressionStream(encoding);
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  const buff = new Response(cs.readable).arrayBuffer();
  return buff;
}

function decompressArrayBufferToString(byteArray, encoding='gzip') {
  const cs = new DecompressionStream(encoding);
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  return new Response(cs.readable).arrayBuffer().then(function (arrayBuffer) {
    return new TextDecoder().decode(arrayBuffer);
  });
}

function encodeArrayBufferToBase64(arrayBuffer) {
  const base64String = btoa(
    new Uint8Array(arrayBuffer)
      .reduce((data, byte) => data + String.fromCharCode(byte), '')
  );
  return base64String;
}

function decodeBase64ToArrayBuffer(base64String) {
  return Uint8Array.from(atob(base64String), c=>c.charCodeAt(0));
}

async function saveToLocalStorage() {
  const ls = window.localStorage;
  try {
    ls.setItem('wordListFilename', wordlist_filename || '');
    ls.setItem('html_language', HTMLLang.value);
    ls.setItem('harfbuzz_script', inputScript.value);
    ls.setItem('harfbuzz_language', inputLanguage.value);
    ls.setItem('start_index', start_index);
    if (hbf1.fontNames) {
      ls.setItem('font1.name',    hbf1.fontNames.fullName);
      ls.setItem('font1.version', hbf1.fontNames.version);
    }
    if (hbf2.fontNames) {
      ls.setItem('font2.name',    hbf2.fontNames.fullName);
      ls.setItem('font2.version', hbf2.fontNames.version);
    }
    const json = JSON.stringify(wordList);
    const buff = await compressStringToArrayBuffer(json);
    const b64 = encodeArrayBufferToBase64(buff);
    ls.setItem('wordList', b64);
    //---- localStorage is VERY limited. Cannot save the font :-(
    //ls.setItem('fontBlob1', JSON.stringify(hbf1.fontBlob));
    //ls.setItem('fontBlob2', JSON.stringify(hbf2.fontBlob));
  } catch(error) {
    window.alert(error);
  }
  resetCheckListChanged(); // Because we've save it
}

function clearLocalStorage() {
  if (!window.confirm('Clear all words, check lists, notes, and localStorage?\r\nCANNOT be undone!!!')) return;
  window.localStorage.clear();
  loadFromLocalStorage();
  resetCheckListChanged(); // Because we've save it
  wordList = [];
  updateCheckListCount();
  UpdateWordCount();
  updateListByIndex(1);
  mapCountsToDisplay([]);
}

var ls_wordlist = [];

function setLastFontDetails(root, id) {
  const ls = window.localStorage;
  var name     = ls.getItem('font'+root+'.name');
  var version  = ls.getItem('font'+root+'.version');
  id.innerHTML = 'Drag-and-Drop Font '+root;
  if (!name) return;
  if (!version) return;
  id.innerHTML = '<font color="red"><em>Drag-and-drop font:</em></br>'
      + name + '</b></br>'
      + '<font size="-1">'+version+'</font></font>';
}


async function loadFromLocalStorage() {
  if (window?.opener?.api?.transfer) return; // NOTE: hack as I have some nasty async issue that calls this AFTER the acquireFromTransfer has been executed
  const ls = window.localStorage;
  var _wl = ls.getItem('wordList');
  var buff;
  try {
    buff = decodeBase64ToArrayBuffer(_wl);
    if (buff) {
      // Wordlist is compressed...
      _wl = await decompressArrayBufferToString(buff);
    }
  } catch(e) {
    buff = null;
  }
  wordlist_filename = ls.getItem('wordListFilename');
  if (_wl) {
    ls_wordlist = JSON.parse(_wl);
    wordList = [];
    var i = 0;
    while (i < ls_wordlist.length) {
      const wle = ls_wordlist[i];
      const wordEntry = new wordEntryClass(wle.word);
      wordEntry.checked = wle.checked;
      wordEntry.note = wle.note;
      wordList.push(wordEntry);
      i++;
    }
    start_index = ls.getItem('start_index');
    if (!start_index) start_index = 1;
    updateCheckListCount();
    UpdateWordCount();
    updateListByIndex(start_index);
    window.scroll(0,0);
    disableSaveButton();
  }
  setLastFontDetails('1', fontOneInfo);
  setLastFontDetails('2', fontTwoInfo);
  showFontTwo(false);
  //---- localStorage is very limited - cannot store the fontBlobs, alas
  //var _fontBlob1 = ls.getItem('fontBlob1');
  //if (_fontBlob1) applyFontX(null, 'Test_Font_1', fontOneInfo, hbf1, _fontBlob1);
  //var _fontBlob2 = ls.getItem('fontBlob2');
  //if (_fontBlob2) applyFontX(null, 'Test_Font_2', fontTwoInfo, hbf2, _fontBlob2);
}

//---------------------------Fill in the text as separate lines------------------
ClearCheckList();
updateListByIndex(1)
//===============================================================================

function showOverlap(phrase, lineNo, event) {
  vectorDisplay.style.display = 'block';
  updateHarfBuzzScriptLanguage();
  hbf1.genSVGcombined(phrase, hbf2, event.ctrlKey);
}

function hideOverlap(event) {
  vectorDisplay.style.display = 'none';
}

function UpdateWordCount() {
  var wlc = document.getElementById('wordcount');
  var txt = 'Count:'+wordList.length;
  if (typeof wordlist_filename === 'string') {
    txt = txt + ' '+wordlist_filename;
  }
  wlc.innerHTML = txt;
}

//------------------------------
// Drag and drop functions
//------------------------------
function handleWordsDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Continue?')) return;
  }

  wordlist_filename = '"'+fileName+'"';
  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    wordList = buildListFromFileContents(txt);
    ClearCheckList();
    updateListByIndex(1);
    UpdateWordCount();
    enableSaveButton();
  }
  reader.readAsText(file);
}

function handleCheckDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    var checkWordList = buildListFromFileContents(txt);
    var i = 0;
    var cache = {};
    while (i < checkWordList.length) {
      const cwle = checkWordList[i];
      const word = cwle.getWord();
      var mi = findWordInList(wordList, word, cache);
      var note = cwle.getNote();
      if (mi >= 0) {
        wordList[mi].setChecked(true);
        if (note && (note.length > 0)) {
          wordList[mi].setNote(note);
        }
      } else {
        const newEntry = new wordEntryClass(word);
        newEntry.setNote(note);
        newEntry.setChecked(true);
        addToList(wordList, newEntry, cache);
      }
      i++;
    }
    checkListHasChanged();
    updateCheckListCount();
    updateListByField();
    UpdateWordCount();
  }
  reader.readAsText(file);
}

function applyFontX(file, fontname, id, hbo, data) {
  hbo.setFontBlob(new Uint8Array(data));
  const fontFace = new FontFace(fontname, data);
  const fontInfo = FontName.parse(data);
  const fontName = fontInfo[0];
  hbo.fontNames = fontName;
  id.innerHTML = fontName.fullName + '</b></br><font size="-1">' + fontName.version + "</font>";
  fontFace.load().then(
    () => {
      deleteFontByName(fontname);
      document.fonts.add(fontFace);
      //--//if (file) console.log('loaded '+file.name);
      changeFontAscentDescent(fontname, '200%', '200%');
      fontsHaveChanged();
      updateListByField();
      updateLanguage();
      if (hbo === hbf1) {
        //NOTE: if debug is not available, we can still use gid # and gpos table #
        //regExpGlyph.disabled = !hbf1.getGlyphName(0);
        //regExpGpos.disabled = !hbf1.debugInfo;
        regExpGlyph.disabled = false;
        regExpGpos.disabled = false;
        gidGposAnalytics.hidden = false;
      }
    },
    (err) => {
      console.error(err);
    }
    );
}

function handleFontXDrop(file, fontname, id, hbo) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.ttf') && !fileName.endsWith('.otf')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    applyFontX(file, fontname, id, hbo, reader.result);
    saveToLocalStorage();
  }
  reader.readAsArrayBuffer(file);
}

function handleFontOneDrop(file) {
  handleFontXDrop(file, 'Test_Font_1', fontOneInfo, hbf1);
}

function handleFontTwoDrop(file) {
  handleFontXDrop(file, 'Test_Font_2', fontTwoInfo, hbf2);
  showFontTwo(true);
}

patchDragDrop(WordsDragDrop, handleWordsDrop);
patchDragDrop(CheckDragDrop, handleCheckDrop);
patchDragDrop(fontOneInfo, handleFontOneDrop);
patchDragDrop(fontTwoInfoCell, handleFontTwoDrop);

showFontTwo(false);

</script>

<p></br>HarfBuzz Version: <span id="hbversion"></span>
</br>Tool Version: 2025-10-28 o</p>
</body>
</html>
