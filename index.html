<html>

<head>
<meta charset="utf-8">
<!--
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gulzar|Noto+Nastaliq+Urdu">
-->
<style>
  body {
    font-family: "Calibri";
    background-color: #aacccc;
  }
.test_1 {
  font-family: "Test_Font_1";
  font-kerning: normal;
  font-size: 200%;
  color: #000080;
  text-align: center;
}

.test_2 {
  font-family: "Test_Font_2";
  font-kerning: normal;
  font-size: 200%;
  color: #ee6600;
  text-align: center;
}

.HBC {
  font-family: "Consolas";
  text-align: center;
}

.overlap {
  text-align: center;
  line-height: 0px;
}

input[type="text"] {
  font-size: 100%;
}
table, th, td {
  border: 2px solid #448888;
  border-collapse: collapse;
  padding: 8px;
}
td {
  align: 'left';
}
.wordlist, input[type="file"] {
  background-color: #8ebf42;
}
</style>

<script type="text/javascript" src="hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="hbjs.js"></script> <!-- Wrapper, can be used without -->
<script type="text/javascript" src="fontname.min.js"></script>
<script>

let harfBuzzModule; // not really needed with the hbjs wrapper
createHarfBuzz().then(hbmodule=>{
  harfBuzzModule = hbmodule;
  window.hb = hbjs(hbmodule);
  hbversion.innerHTML = hb.version_string();
});

//------------------------------
// Drag and drop utilities
//------------------------------
function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);
window.addEventListener('beforeunload', function(e) {
  if (!checkListChanged) return undefined;
  var confirmMessage = 'CheckList is not yet saved. If you leave before saving, changes will be lost!';
  (e || window.event).returnValue = confirmMessage;
  return confirmMessage;
});


//------------------------------
// Document/CSS Font Utilities
//------------------------------
function changeFontAscentDescent(name, asc, desc) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        v.ascentOverride  = asc;
        v.descentOverride = desc;
      }
    }
  );
}

function deleteFontByName(name) {
  document.fonts.forEach(
    (v) => {
      if (v.family == name) {
        document.fonts.delete(v);
      }
    }
  );
}

//------------------------------
// Build table
//------------------------------
start_index = 1
per_block = 100
line = 1
function wordHTML(txt,fnt) {
  //return '<div class="'+fnt+'" align="center"><p>'+txt+'</p></div>'
  return '<div class="'+fnt+'"><p>'+txt+'</p></div>'
}

function MarkUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setChecked(e.checked);
  updateCheckListCount();
  checkListChanged = true;
}

function BuildMarkHtml(n) {
  var txt = '<input type="checkbox" onclick="MarkUpdate(this);" name="mark'+(n+1)+'"';
  if (wordList[n].getChecked()) txt = txt + ' checked';
  txt = txt + '>';
  return txt;
}

function NoteUpdate(e) {
  var n = e.name;
  n = parseInt(n.substring(4)) - 1;
  wordList[n].setNote(e.value);
  checkListChanged = true;
}

function BuildNoteHtml(n) {
  var txt = '<input type="text" onchange="NoteUpdate(this);" onkeyup="NoteUpdate(this);" name="note'+(n+1)+'" value="';
  txt = txt + wordList[n].getNote();
  txt = txt + '" size=8>';
  return txt;
}

var hb_icon_identical = '&#x2705;';
var hb_icon_length    = '&#x1F4A5;';  //collision
var hb_icon_advance   = '&#x1F525;';  //fire
var hb_icon_offset    = '&#x1F53A;';  //up red triangle
var hb_icon_cluster   = '&#x1F4A0;';  //diamond (blue)
var hb_icon_gid       = '';

function diffFieldToText(diff) {
  var res = '';
  if (diff < 0) return '';
  if (diff == 0) return hb_icon_identical;
  if (0 != (diff & 128)) res = res + hb_icon_length + "</br>";
  if (0 != (diff & 8))   res = res + hb_icon_advance + "</br>";
  if (0 != (diff & 4))   res = res + hb_icon_offset + "</br>";
  if (0 != (diff & 2))   res = res + hb_icon_cluster + "</br>";
  if (0 != (diff & 1))   res = res + hb_icon_gid;// + "</br>";
  return res;
}

function addEntry(lineNo, theWordEntry) {
  //if (txt == '') return;
  var table = document.getElementById('word_list');
  var row = table.insertRow();
  var idx=1;

  var phrase = theWordEntry.getWord();
  hbf1.shape(phrase);
  hbf2.shape(phrase);
  var diff = hbf1.compare(hbf2);

  row.insertCell(0).innerHTML = '<div align="center">'+(lineNo+1)+
      BuildMarkHtml(lineNo)+' '+BuildNoteHtml(lineNo)+'</div>';
  row.insertCell(idx++).innerHTML = '<div class="HBC">'+
      diffFieldToText(diff)+'</div>';
  row.insertCell(idx++).innerHTML = wordHTML(phrase, "test_1");
  row.insertCell(idx++).innerHTML = wordHTML(phrase, "test_2");
  row.insertCell(idx++).innerHTML =
      //'<p style="line-height: 0px; " align="center">'
      '<p class="overlap">'
    + '<span class="test_2" style="color: #ff6600;">' + phrase + '</span><br>'
    + '<span class="test_1">' + phrase + '</span></p>'
}
function addrow() {
  var field = document.getElementById("text");
  var txt = field.value;
  addUrdu(line, txt)
  line++;
  field.value = '';
}
function dokey(ele) {
  ele.preventDefault();
  if (ele.keyCode == 13) {
    addrow();
  }
  return false;
}
function updateListByIndex(idx) {
  hbf1.setScriptLang(HBScript.value, HBLang.value);
  hbf2.setScriptLang(HBScript.value, HBLang.value);

  var table = document.getElementById('word_list')
  var s = table.rows.length;
  while (s > 1) {
    s--;
    table.deleteRow(s);
  }
  var n =  per_block;
  for (i=(idx-1); i < (idx-1+n); i++) {
    if (wordList[i] === undefined) break;
    addEntry(i, wordList[i]);
  }
  document.getElementById('start').value = String(idx);
}
function getStart() {
  var i = Number(document.getElementById('start').value);
  if (i < 1) {
    i = 1;
  }
  if (i > wordList.length) {
    i = wordList.length-1;
  }
  return i;
}
function setStart(idx) {
  document.getElementById('start').value = String(idx);
}
function updateListByField() {
  start_index = getStart();
  if (start_index <= 1) start_index = 1;
  setStart(start_index);
  updateListByIndex(start_index);
}
function updateListNext() {
  start_index = getStart() + per_block;
  if (start_index > wordList.length) start_index = wordList.length - 2;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}
function updateListPrev() {
  start_index = getStart() - per_block;
  if (start_index < 1) start_index = 1;
  updateListByIndex(start_index);
}


function updateCssStyle(name, styleid, value) {
  const rules = document.styleSheets[0].cssRules;
  for (var i=0; i<rules.length; i++) {
    if (rules[i].selectorText == name) {
      rules[i].style[styleid] = value;
      break;
    }
  }
}
function updateAlign() {
  const alignRadios = document.getElementsByName('alignment');
  var text_align = 'center';
  for (var i=0; i<alignRadios.length; i++) {
    if (alignRadios[i].checked) {
      text_align = alignRadios[i].value;
      break;
    }
  }
  updateCssStyle('.test_1', 'text-align', text_align);
  updateCssStyle('.test_2', 'text-align', text_align);
  updateCssStyle('.overlap', 'text-align', text_align);
}

</script>
</head>

<body>

<h1>
  Compare Font Word List Tool
</h1>

<label for='start'>Start:</label><input type='text' id='start' placeholder='Start' value='1'/>
<button onclick='updateListByField();'>Go</button>
<button onclick='updateListPrev();' accesskey='2'>Prev (Alt-2)</button>
<button onclick='updateListNext();' accesskey='3'>Next (Alt-3)</button>
<span id='wordcount'></span>
</br>
<span>
  <input type='radio' name='alignment' value='left' onclick="updateAlign();">
    <label for='left'>Left</label>
  <input type='radio' name='alignment' value='center' onclick="updateAlign();" checked>
    <label for='center'>Center</label>
  <input type='radio' name='alignment' value='right' onclick="updateAlign();">
    <label for='right'>Right</label>
</span>

<table border=2 cellspacing="8px" width='100%' id='word_list'>
  <tr>
    <th width='16%'># / Note</th>
    <th width='6%'><a href='javascript:void(0)' onclick='toggleHBIcons();'>Diff</a>
      <div id='HBIcons' hidden>
      </div>
    </th>
    <th width='26%' id='fontOneInfo'>Drag-and-Drop Font 1</th>
    <th width='26%' id='fontTwoInfo'>Drag-and-Drop Font 2</th>
    <th width='26%'>Overlap</th>
  </tr>
</table>

</p>

<p>
<button onclick='updateListByField(); window && window.scroll(0,0)'>TOP</button>
<button onclick='updateListNext(); window && window.scroll(0,0)'>Next</button>
</p>
<table width="100%" border=1>
  <tr>
    <th width="20%">CheckList <span id="CheckListCount"></span></th>
    <th>Word List</th>
  </tr>
  <tr>
    <td id='CheckDragDrop' align='center'>Drag-and-drop CheckList .txt here</br>
      <button onclick='DownloadCheckList();'>Download</button> &bull;
      <button onclick='ClearCheckListUser();'>Clear All</button> &bull;
      <button onclick='InvertCheckList();'>Invert</button> &bull;
      <button onclick='CheckNotes();'>Check Notes</button>
      </br>
      HarfBuzz Operations:</br>
      <button onclick='CheckSimilar();'>Check Similar</button> &bull;
      <button onclick='UpdateDifferences();'>Update Differences</button>
    </td>
    <td id='WordsDragDrop' align='center'>Drag-and-drop Word List .txt file here</br>
      <button onclick='RemoveUnchecked();'>Delete Unchecked</button></br>
      <a href='javascript:void(0)' onclick='togglePropertiesVisibility(); return false;' id='hrefLanguageProperties'>
        Show Lang/Script
      </a>
      <div id='languageProperties' hidden>
      <table border=1>
        <tr><th>HTML Lang:</th><td><input type='text' id='HTMLLang' oninput='updateLanguage();'/></td></tr>
        <tr><th>HarfBuzz Script:</th><td><input type='text' id='HBScript' oninput='updateLanguage();'/></td></tr>
        <tr><th>HarfBuzz Lang:</th><td><input type='text' id='HBLang' oninput='updateLanguage();'/></td></tr>
      </table>
      </div>
      <div id='statusUpdate'>-</div>
    </td>
  </tr>
</table>
</p>

<script>

class hbFont {
  constructor() {
    this.script = 'latn';
    this.lang   = '';
    this.features = '';
    this.results = {};
    this.results.json = null;
  }
  destroy() {
    this.freeFontBlob();
  }
  freeFontBlob() {
    this.freeFont();
    this.fileDescription = null;
    delete(this.fontBlob);
  }
  freeFont() {
    this.results = {};
    if (this.font) { this.font.destroy(); delete(this.font); }
    if (this.face) { this.face.destroy(); delete(this.face); }
    if (this.blob) { this.blob.destroy(); delete(this.blob); }
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    if (fb) {
      const fontName = FontName.parse(fb)[0];
      console.log(fontName);
      this.fileDescription = fontName.fullName + '</br>' + fontName.version;
    } else {
      this.fileDescription = '';
    }
    if (!fb) return;
    this.blob = hb.createBlob(this.fontBlob);
    this.face = hb.createFace(this.blob, 0);
    this.font = hb.createFont(this.face);
  }
  setScriptLang(script, lang) {
    this.script = script;
    this.lang = lang;
  }
  shape(txt) {
    if (!this.fontBlob) return;
    var buffer = hb.createBuffer();
    buffer.addText(txt);
    buffer.guessSegmentProperties();
    if (this.script && (this.script.length > 0))
      buffer.setScript(this.script || 'latn');
    if (this.lang && (this.lang.length > 0))
      buffer.setLanguage(this.lang);
    hb.shape(this.font, buffer, this.features);
    this.results.json = buffer.json(this.font);
    buffer.destroy();
  }
  compare(hb2) {
    // Returns bit field:
    // 1 = GID different
    // 2 = Cluster different
    // 4 = Offset different
    // 8 = Advance different (e.g. kerning)
    // 128 = different length
    if ( (this.results === null) ||
         (this.results.json === null) ||
         (hb2.results === null) ||
         (hb2.results.json === null)
       )
    {
      return -1;
    }
    var idx = 0;
    var res = 0;
    while (true) {
      if (idx >= this.results.json.length) {
        if (idx < hb2.results.json.length) res |= 128;
        break;
      }
      if (idx >= hb2.results.json.length) {
        res |= 128;
        break;
      }
      const g1 = this.results.json[idx];
      const g2 = hb2.results.json[idx];
      if (g1 === null) {
        if (g1 !== null) res |= 128;
        break;
      }
      if (g2 === null) {
        res |= 128;
        break;
      }
      if (g1.g  !== g2.g)  res |= 1;
      if (g1.cl !== g2.cl) res |= 2;
      if (g1.dx !== g2.dx) res |= 4;
      if (g1.dy !== g2.dy) res |= 4;
      if (g1.ax !== g2.ax) res |= 8;
      if (g1.ay !== g2.ay) res |= 8;
      idx++;
    }
    return res;
  }
}

var hbf1 = new hbFont;
var hbf2 = new hbFont;

class wordEntryClass {
  constructor(line) {
    const tempArray = line.split('\t');
    this.word = tempArray[0];
    this.note = tempArray[1] || '';
    this.checked = false;
    //??//this.checked = (tempArray[2] === 'x') || (tempArray[2] === 'X'); //??
  }
  getWord()     { return this.word; }
  getChecked()  { return this.checked; }
  setChecked(isChecked) { this.checked = isChecked; }
  setNote(txt)  { this.note = txt; }
  getNote()     { return this.note; }
  // The line for the check list file output
  getLine() {
    var txt = this.word;
    if (this.note && (this.note.length > 0)) {
      txt = txt + '\t' + this.note;
    }
    return txt;
  }
}

var wordList = []; // An array of wordEntry objects

function buildListFromFileContents(txt)
{
  var lines = txt.split(/\r?\n+/g);
  var tempWordList = [];  // Start empty
  var i = 0;
  while (i < lines.length) {
    const wordEntry = new wordEntryClass(lines[i]);
    if (wordEntry.getWord().length > 0) {
      tempWordList.push(wordEntry);
    }
    i++;
  }
  return tempWordList;
}

function getWordCheckCount() {
  var count = 0;
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) count++;
    i++;
  }
  return count;
}

function findWordInList(theList, theWord)
{
  var i = 0;
  while (i < theList.length) {
    if (theList[i].getWord() === theWord) {
      return i;
    }
    i++;
  }
  return -1;
}

function updateCheckListCount() {
  var count = getWordCheckCount();
  CheckListCount.innerHTML =' '+count+'/'+wordList.length;
}

function checkBothFontsLoaded() {
  var res = true;
  if (!hbf1.fileDescription) res = false;
  if (!hbf2.fileDescription) res = false;
  if (hbf1.fileDescription === '') res = false;
  if (hbf2.fileDescription === '') res = false;
  if (hbf1.fileDescription === hbf2.fileDescription) res = false;
  if (!res)
  {
    window.alert('Please load two fonts to compare');
  }
  return res;
}

// Show/Hide the language & script fields
function togglePropertiesVisibility() {
  languageProperties.hidden = !languageProperties.hidden;
  let txt = hrefLanguageProperties.text;
  if (languageProperties.hidden)
    hrefLanguageProperties.text = txt.replace('Hide', 'Show');
  else
    hrefLanguageProperties.text = txt.replace('Show', 'Hide');
}

function toggleHBIcons() {
  HBIcons.innerHTML = '</br>'+
    hb_icon_identical + 'exact</br>'+
    hb_icon_length + 'len</br>'+
    hb_icon_advance + 'adv</br>'+
    hb_icon_offset  + 'ofs</br>'+
    hb_icon_cluster + 'clu</br>';
  HBIcons.hidden = !HBIcons.hidden;
}

// Update the document language tag, and the HarfBuzz values
function updateLanguage() {
  document.documentElement.setAttribute('lang', HTMLLang.value);
}

function ClearCheckList() {
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(false);
    i++;
  }
  updateCheckListCount();
  checkListChanged = false;
}

function ClearCheckListUser() {
  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Clear all?')) return;
  }
  ClearCheckList();
  updateListByField();
}

function InvertCheckList() {
  var i = 0;
  while (i < wordList.length) {
    wordList[i].setChecked(!wordList[i].getChecked());
    i++;
  }
  updateCheckListCount();
  checkListChanged = true;
  updateListByField();
}


// See: https://elplatt.com/javascript-updating-dom-during-long-running-computation
function doUntil(loop, stopCondition, yieldCondition) {
    // Wrap function in promise so it can run asynchronously
    return new Promise((resolve, reject) => {

    // Build outerLoop function to pass to setTimeout
    let outerLoop = function () {
      while (true) {
        // Execute a single inner loop iteration
        loop();

        if (stopCondition()) {
            // Resolve promise, exit outer loop,
                        // and do not re-enter
            resolve();
            break;
        } else if (yieldCondition()) {
            // Exit outer loop and queue up next
                        // outer loop iteration for next event loop cycle
            setTimeout(outerLoop, 0);
            break;
        }
        // Continue to next inner loop iteration
        // without yielding
      }
    };

    // Start the first iteration of outer loop,
    // unless the stop condition is met
    if (!stopCondition()) {
        setTimeout(outerLoop, 0);
    }
  });
}

function updateStatusMessage(i, total) {
  if (i <= 0)
    statusUpdate.innerHTML = '-';
  else
    statusUpdate.innerHTML = '<div><font color="red">'+i + '/'+ total+'</font></div>';
}

function CheckSimilar() {
  let i = 0;
  const total = wordList.length;

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }

  const stopCondition = () => i >= total;
  const yieldCondition = () => i % 1000 == 0;

  hbf1.setScriptLang(HBScript.value, HBLang.value);
  hbf2.setScriptLang(HBScript.value, HBLang.value);

  const loop = () => {
    var phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2);
    if ((diff == 1) || (diff == 0)) {
      wordList[i].setChecked(true);
    }
    i++;
    if (yieldCondition()) {
      updateStatusMessage(i, total);
    }
    if (stopCondition()) {
      checkListChanged = true;
      updateCheckListCount();
      UpdateWordCount();
      updateListByIndex(1);
      window.scroll(0,0);
      updateStatusMessage(-1);
    }
  }

  doUntil(loop, stopCondition, yieldCondition);
}

function CheckNotes() {
  var i = 0;
  while (i < wordList.length) {
    var note = wordList[i].getNote();
    if (note && (note.length > 0)) {
      wordList[i].setChecked(true);
    }
    i++;
  }
  updateListByIndex(1);
  window.scroll(0,0);
  updateStatusMessage(-1);
}

function UpdateDifferences() {
  let i = 0;
  const total = wordList.length;

  if (!checkBothFontsLoaded()) return;
  if (total > 5000) {
    if (!window.confirm('This will take a LONG time. Continue?')) return;
  }

  const stopCondition = () => i >= total;
  const yieldCondition = () => i % 1000 == 0;

  hbf1.setScriptLang(HBScript.value, HBLang.value);
  hbf2.setScriptLang(HBScript.value, HBLang.value);

  const loop = () => {
    var phrase = wordList[i].getWord();
    hbf1.shape(phrase);
    hbf2.shape(phrase);
    var diff = hbf1.compare(hbf2);
    if ((diff == 1) || (diff == 0)) {
      wordList[i].setChecked(!wordList[i].getChecked());
    }
    i++;
    if (yieldCondition()) {
      updateStatusMessage(i, total);
    }
    if (stopCondition()) {
      checkListChanged = true;
      updateCheckListCount();
      UpdateWordCount();
      updateListByIndex(1);
      window.scroll(0,0);
      updateStatusMessage(-1);
    }
  }

  doUntil(loop, stopCondition, yieldCondition);
}

function RemoveUnchecked() {
  if (!window.confirm('Delete all unchecked words? (Cannot be undone!)')) return;
  var i = 0;
  var counter = 0;
  var newWordList = [];
  const stopCondition = () => i >= wordList.length;
  const yieldCondition= () => (counter % 1000) ==0;
  const loop = () => {
    counter++;
    if (wordList[i].getChecked()) {
      newWordList.push(wordList[i]);
    }
    i++;
    if (yieldCondition()) {
      updateStatusMessage(i, wordList.length);
    }
    if (stopCondition()) {
      wordList = newWordList; // Assign the new updated list
      if (!wordlist_filename.endsWith('(edited)')) wordlist_filename = wordlist_filename + ' (edited)';
      UpdateWordCount();
      updateCheckListCount();
      updateListByIndex(1);
      updateStatusMessage(-1);
    }
  }
  doUntil(loop, stopCondition, yieldCondition);
}

function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function DownloadCheckList() {
  var txt = '';
  var i = 0;
  while (i < wordList.length) {
    if (wordList[i].getChecked()) {
      txt = txt + wordList[i].getLine()+'\n';
    }
    i++;
  }
  var bb = new Blob([txt], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = 'CheckList.'+DateTimeForFilename()+'.txt';
  a.href = window.URL.createObjectURL(bb);
  a.target='_blank';
  a.click();
  //document.body.removeChild(a);
}

//---------------------------Fill in the text as separate lines------------------
ClearCheckList();
updateListByIndex(1)
//===============================================================================


function UpdateWordCount() {
  var wlc = document.getElementById('wordcount');
  var txt = 'Count:'+wordList.length;
  if (wordlist_filename) txt = txt + ' '+wordlist_filename;
  wlc.innerHTML = txt;
}

//------------------------------
// Drag and drop functions
//------------------------------
function handleWordsDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  if (checkListChanged) {
    if (!window.confirm('Check List has changed! Continue?')) return;
  }

  wordlist_filename = '"'+fileName+'"';
  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    wordList = buildListFromFileContents(txt);
    ClearCheckList();
    updateListByIndex(1);
    UpdateWordCount();
  }
  reader.readAsText(file);
}

function handleCheckDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    var checkWordList = buildListFromFileContents(txt);
    var i = 0;
    while (i < checkWordList.length) {
      var mi = findWordInList(wordList, checkWordList[i].getWord());
      var note = checkWordList[i].getNote();
      if (mi >= 0) {
        wordList[mi].setChecked(true);
        if (note && (note.length > 0)) {
          wordList[mi].setNote(note);
        }
      } else {
        const newEntry = new wordEntryClass(checkWordList[i].getWord());
        newEntry.setNote(note);
        newEntry.setChecked(true);
        wordList.push(newEntry);
      }
      i++;
    }
    checkListChanged = true;
    updateCheckListCount();
    updateListByField();
    UpdateWordCount();
  }
  reader.readAsText(file);
}

function handleFontXDrop(file, fontname, id, hbo) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.ttf') && !fileName.endsWith('.otf')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    hbo.setFontBlob(new Uint8Array(reader.result));
    const fontFace = new FontFace(fontname, reader.result);
    const fontInfo = FontName.parse(reader.result);
    const fontName = fontInfo[0];
    id.innerHTML = fontName.fullName + '</b></br><font size="-1">' + fontName.version + "</font>";
    fontFace.load().then(
      () => {
        deleteFontByName(fontname);
        document.fonts.add(fontFace);
        console.log('loaded '+file.name);
        changeFontAscentDescent(fontname, '200%', '200%');
        updateListByField();
      },
      (err) => {
        console.error(err);
      }
      );
  }
  reader.readAsArrayBuffer(file);
}

function handleFontOneDrop(file) {
  handleFontXDrop(file, 'Test_Font_1', fontOneInfo, hbf1);
}

function handleFontTwoDrop(file) {
  handleFontXDrop(file, 'Test_Font_2', fontTwoInfo, hbf2);
}

patchDragDrop(WordsDragDrop, handleWordsDrop);
patchDragDrop(CheckDragDrop, handleCheckDrop);
patchDragDrop(fontOneInfo, handleFontOneDrop);
patchDragDrop(fontTwoInfo, handleFontTwoDrop);

</script>

<p></br>HarfBuzz Version: <span id="hbversion"></span>
</br>Tool Version: 2025-01-30</p>
</body>
</html>
